<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LOOS: loos Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LOOS<span id="projectnumber">&#160;4.1.0</span>
   </div>
   <div id="projectbrief">The Lightweight Object Oriented Structural analysis library/toolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">loos Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Namespace for most things not already encapsulated within a class.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceloos_1_1_density_tools" id="r_namespaceloos_1_1_density_tools"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos_1_1_density_tools.html">DensityTools</a></td></tr>
<tr class="memdesc:namespaceloos_1_1_density_tools"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for Density package. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceloos_1_1internal" id="r_namespaceloos_1_1internal"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos_1_1internal.html">internal</a></td></tr>
<tr class="memdesc:namespaceloos_1_1internal"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loos esoterica. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceloos_1_1_math" id="r_namespaceloos_1_1_math"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos_1_1_math.html">Math</a></td></tr>
<tr class="memdesc:namespaceloos_1_1_math"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for math and math-related things in loos. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceloos_1_1_options_framework" id="r_namespaceloos_1_1_options_framework"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceloos_1_1_options_framework.html">OptionsFramework</a></td></tr>
<tr class="memdesc:namespaceloos_1_1_options_framework"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for encapsulating options processing. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_abstract_observer.html">AbstractObserver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_amber.html">Amber</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for reading in AMBER parmtop/coord files...  <a href="classloos_1_1_amber.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_amber_netcdf.html">AmberNetcdf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for reading <a class="el" href="classloos_1_1_amber.html" title="Class for reading in AMBER parmtop/coord files...">Amber</a> Trajectories in NetCDF format.  <a href="classloos_1_1_amber_netcdf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_amber_rst.html">AmberRst</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for reading amber restart files as a single-frame trajectory.  <a href="classloos_1_1_amber_rst.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_amber_traj.html">AmberTraj</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for reading amber coordinate trajectories.  <a href="classloos_1_1_amber_traj.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_and_selector.html">AndSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines two selectors with a logical "and".  <a href="structloos_1_1_and_selector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_ascending_sort.html">AscendingSort</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Policy class for sorting in ascending sequence.  <a href="classloos_1_1_ascending_sort.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atom.html">Atom</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic <a class="el" href="classloos_1_1_atom.html" title="Basic Atom class for handling atom properties.">Atom</a> class for handling atom properties.  <a href="classloos_1_1_atom.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_atom_coords_equals.html">AtomCoordsEquals</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two atoms based on name, id, resid, resname, segid, and coords.  <a href="structloos_1_1_atom_coords_equals.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_atom_equals.html">AtomEquals</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two atoms based solely on name, id, resid, resname, and segid.  <a href="structloos_1_1_atom_equals.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for handling groups of Atoms (pAtoms, actually)  <a href="classloos_1_1_atomic_group.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_atom_name_selector.html">AtomNameSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate for selecting atoms based on explicit name matching.  <a href="structloos_1_1_atom_name_selector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_atom_selector.html">AtomSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual base-class for selecting atoms from a group.  <a href="structloos_1_1_atom_selector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_backbone_selector.html">BackboneSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate for selecting backbone.  <a href="classloos_1_1_backbone_selector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_basic_progress.html">BasicProgress</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_bound_fmt.html">BoundFmt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal helper class to bind formatting state.  <a href="structloos_1_1_bound_fmt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_c_alpha_selector.html">CAlphaSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate for selecting CA atoms.  <a href="structloos_1_1_c_alpha_selector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_c_c_p_d_b.html">CCPDB</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for interpreting concatenated <a class="el" href="classloos_1_1_p_d_b.html" title="PDB reading/writing class.">PDB</a> files as a <a class="el" href="classloos_1_1_trajectory.html" title="Base-class for polymorphic trajectories.">Trajectory</a>.  <a href="classloos_1_1_c_c_p_d_b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_c_h_a_r_m_m.html">CHARMM</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for reading a <a class="el" href="classloos_1_1_c_h_a_r_m_m.html" title="Class for reading a CHARMM coordinate file.">CHARMM</a> coordinate file.  <a href="classloos_1_1_c_h_a_r_m_m.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_coord.html">Coord</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic 3-D coordinates class.  <a href="classloos_1_1_coord.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_d_c_d.html">DCD</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for reading <a class="el" href="classloos_1_1_d_c_d.html" title="Class for reading DCD files.">DCD</a> files.  <a href="classloos_1_1_d_c_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_d_c_d_writer.html">DCDWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <em>very</em> lightweight class for writing simple DCDs.  <a href="classloos_1_1_d_c_d_writer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_descending_sort.html">DescendingSort</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Policy class for sorting in descending sequence.  <a href="classloos_1_1_descending_sort.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_estimating_counter.html">EstimatingCounter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A progress counter that can estimate how much time is left.  <a href="classloos_1_1_estimating_counter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_file_error.html">FileError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Errors related to File I/O.  <a href="classloos_1_1_file_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_file_open_error.html">FileOpenError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error while opening a file.  <a href="classloos_1_1_file_open_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_file_read_error.html">FileReadError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Errors that occur while reading a file.  <a href="classloos_1_1_file_read_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_file_read_error_with_line.html">FileReadErrorWithLine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Errors that occur while reading a text file (where lines are tracked)  <a href="classloos_1_1_file_read_error_with_line.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_file_write_error.html">FileWriteError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Errors while writing to files.  <a href="classloos_1_1_file_write_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_fmt.html">Fmt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output formatter class, adapted from Stroustrup's book.  <a href="classloos_1_1_fmt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_form_factor.html">FormFactor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_form_factor_set.html">FormFactorSet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_gromacs.html">Gromacs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a GROMACS model file (.gro)  <a href="classloos_1_1_gromacs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_h_bond_detector.html">HBondDetector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for detecting hydrogen bonds.  <a href="classloos_1_1_h_bond_detector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_heavy_atom_selector.html">HeavyAtomSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select non-hydrogen atoms.  <a href="structloos_1_1_heavy_atom_selector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_heavy_solvent_selector.html">HeavySolventSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select only heavy solvent atoms.  <a href="structloos_1_1_heavy_solvent_selector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_hydrogen_selector.html">HydrogenSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select hydrogen atoms.  <a href="structloos_1_1_hydrogen_selector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_index_selector.html">IndexSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate for selecting atoms based on index.  <a href="structloos_1_1_index_selector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_kernel.html">Kernel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classloos_1_1_kernel.html" title="The Kernel (virtual machine) for compiling and executing user-defined atom selections.">Kernel</a> (virtual machine) for compiling and executing user-defined atom selections.  <a href="classloos_1_1_kernel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_kernel_selector.html">KernelSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selection predicate that executes a compiled <a class="el" href="classloos_1_1_kernel.html" title="The Kernel (virtual machine) for compiling and executing user-defined atom selections.">Kernel</a>.  <a href="classloos_1_1_kernel_selector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_line_reader.html">LineReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for reading line-by-line from a file while tracking line numbers and stripping comments.  <a href="classloos_1_1_line_reader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_l_o_o_s_error.html">LOOSError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic LOOS exception.  <a href="classloos_1_1_l_o_o_s_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_matrix44.html">Matrix44</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized 4x4 Matrix class for handling coordinate transforms.  <a href="classloos_1_1_matrix44.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_matrix_read_error.html">MatrixReadError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic reading error class.  <a href="classloos_1_1_matrix_read_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_matrix_read_impl.html">MatrixReadImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_matrix_read_impl_3_01_t_00_01_math_1_1_triangular_00_01_s_01_4.html">MatrixReadImpl&lt; T, Math::Triangular, S &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special handling for triangular matrices.  <a href="structloos_1_1_matrix_read_impl_3_01_t_00_01_math_1_1_triangular_00_01_s_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_matrix_read_impl_3_01_t_00_01_p_00_01_math_1_1_sparse_array_01_4.html">MatrixReadImpl&lt; T, P, Math::SparseArray &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special handling for sparse matrices.  <a href="structloos_1_1_matrix_read_impl_3_01_t_00_01_p_00_01_math_1_1_sparse_array_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_matrix_write_impl.html">MatrixWriteImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_matrix_write_impl_3_01_t_00_01_math_1_1_triangular_00_01_s_00_01_f_01_4.html">MatrixWriteImpl&lt; T, Math::Triangular, S, F &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write out a triangular matrix.  <a href="structloos_1_1_matrix_write_impl_3_01_t_00_01_math_1_1_triangular_00_01_s_00_01_f_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_matrix_write_impl_3_01_t_00_01_p_00_01_math_1_1_sparse_array_00_01_f_01_4.html">MatrixWriteImpl&lt; T, P, Math::SparseArray, F &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write out a sparse matrix.  <a href="structloos_1_1_matrix_write_impl_3_01_t_00_01_p_00_01_math_1_1_sparse_array_00_01_f_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_m_d_traj.html">MDTraj</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for reading a <a class="el" href="classloos_1_1_m_d_traj.html" title="Class for reading a MDTraj HDF5 file.">MDTraj</a> HDF5 file.  <a href="classloos_1_1_m_d_traj.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_m_d_traj_traj.html">MDTrajTraj</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for reading <a class="el" href="classloos_1_1_m_d_traj.html" title="Class for reading a MDTraj HDF5 file.">MDTraj</a> HDF5 coordinate trajectories.  <a href="classloos_1_1_m_d_traj_traj.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_m_m_c_i_f.html">MMCIF</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to read pdbx/mmcif files.  <a href="classloos_1_1_m_m_c_i_f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_multi_trajectory.html">MultiTrajectory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine multiple trajectories (pTraj's) into one large virtual trajectory.  <a href="classloos_1_1_multi_trajectory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_not_selector.html">NotSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negates a selection predicate.  <a href="structloos_1_1_not_selector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_numerical_error.html">NumericalError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception caused by a blas/atlas error.  <a href="classloos_1_1_numerical_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_options_error.html">OptionsError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception in options.  <a href="classloos_1_1_options_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_or_selector.html">OrSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines two selectors with a logical "or".  <a href="structloos_1_1_or_selector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_parse_error.html">ParseError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception when parsing input data.  <a href="classloos_1_1_parse_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_parser.html">Parser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Front-end to the Bison/Flex parser.  <a href="classloos_1_1_parser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_parser_driver.html">ParserDriver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_p_d_b.html">PDB</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classloos_1_1_p_d_b.html" title="PDB reading/writing class.">PDB</a> reading/writing class.  <a href="classloos_1_1_p_d_b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_p_d_b_traj.html">PDBTraj</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for intepreting separate <a class="el" href="classloos_1_1_p_d_b.html" title="PDB reading/writing class.">PDB</a> files as a single trajectory.  <a href="classloos_1_1_p_d_b_traj.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_percent_progress.html">PercentProgress</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide feedback by percent-complete.  <a href="classloos_1_1_percent_progress.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_percent_progress_with_time.html">PercentProgressWithTime</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_percent_trigger.html">PercentTrigger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigger whenever at least frac percent more iterations have happened.  <a href="classloos_1_1_percent_trigger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_periodic_box.html">PeriodicBox</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for managing periodic box information.  <a href="classloos_1_1_periodic_box.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_precise_matrix_formatter.html">PreciseMatrixFormatter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic matrix element formatter allowing setting of width and precision.  <a href="classloos_1_1_precise_matrix_formatter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_progress_counter.html">ProgressCounter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The progress counter front-end.  <a href="classloos_1_1_progress_counter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_p_s_f.html">PSF</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for reading a subset of the <a class="el" href="classloos_1_1_p_s_f.html" title="Class for reading a subset of the PSF format.">PSF</a> format.  <a href="classloos_1_1_p_s_f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_remarks.html">Remarks</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for handling <a class="el" href="classloos_1_1_p_d_b.html" title="PDB reading/writing class.">PDB</a> <a class="el" href="classloos_1_1_remarks.html" title="Class for handling PDB Remarks.">Remarks</a>.  <a href="classloos_1_1_remarks.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_resid_range_selector.html">ResidRangeSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate for selecting atoms from a range of resid's.  <a href="structloos_1_1_resid_range_selector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_rna_suite.html">RnaSuite</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for assigning backbone suites to an RNA.  <a href="classloos_1_1_rna_suite.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_scientific_matrix_formatter.html">ScientificMatrixFormatter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic matrix element formatter using scientific notation...  <a href="classloos_1_1_scientific_matrix_formatter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_segid_selector.html">SegidSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate for selecting atoms based on the passed segid string.  <a href="structloos_1_1_segid_selector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_shared_periodic_box.html">SharedPeriodicBox</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class manages a shared Periodicbox.  <a href="classloos_1_1_shared_periodic_box.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_simple_counter.html">SimpleCounter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic progress counter object, defining the interface...  <a href="classloos_1_1_simple_counter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_solvent_selector.html">SolventSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate for selecting solvent based on common solvent SEGIDs.  <a href="structloos_1_1_solvent_selector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_stream_wrapper.html">StreamWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple wrapper class for caching stream pointers.  <a href="classloos_1_1_stream_wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_timer.html">Timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for tracking time.  <a href="classloos_1_1_timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_time_series.html">TimeSeries</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time Series Class.  <a href="classloos_1_1_time_series.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_tinker_arc.html">TinkerArc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for handling Tinker ARC files (concatenation of .xyz files)  <a href="classloos_1_1_tinker_arc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_tinker_x_y_z.html">TinkerXYZ</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for reading a subset of the <a class="el" href="classloos_1_1_tinker_x_y_z.html" title="Class for reading a subset of the TinkerXYZ format.">TinkerXYZ</a> format.  <a href="classloos_1_1_tinker_x_y_z.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_trajectory.html">Trajectory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base-class for polymorphic trajectories.  <a href="classloos_1_1_trajectory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_trajectory_error.html">TrajectoryError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Errors related to trajectory reading and writing.  <a href="classloos_1_1_trajectory_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_trajectory_writer.html">TrajectoryWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for writing trajectories.  <a href="classloos_1_1_trajectory_writer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_trigger_always.html">TriggerAlways</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a simple "trigger" for use as a default.  <a href="classloos_1_1_trigger_always.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_trigger_every.html">TriggerEvery</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigger every i-iterations.  <a href="classloos_1_1_trigger_every.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_t_r_r.html">TRR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing the GROMACS <a class="el" href="classloos_1_1_t_r_r.html" title="Class representing the GROMACS TRR trajectory files.">TRR</a> trajectory files.  <a href="classloos_1_1_t_r_r.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_uniform_weight.html">UniformWeight</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_unique_strings.html">UniqueStrings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for uniquifying strings...  <a href="classloos_1_1_unique_strings.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_unit_cell.html">UnitCell</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class encapsulates crystallographic unit cell data.  <a href="classloos_1_1_unit_cell.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1unordered__pair__eq.html">unordered_pair_eq</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">test equality of unordered pair. typename T must have == operator.  <a href="structloos_1_1unordered__pair__eq.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1unordered__pair__hash.html">unordered_pair_hash</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_unset_property.html">UnsetProperty</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception when trying to use an unset <a class="el" href="classloos_1_1_atom.html" title="Basic Atom class for handling atom properties.">Atom</a> property.  <a href="classloos_1_1_unset_property.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_user_timer.html">UserTimer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Policy class for tracking only user process time.  <a href="classloos_1_1_user_timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_wall_timer.html">WallTimer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Policy class for tracking wall-time.  <a href="classloos_1_1_wall_timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_weights.html">Weights</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_weights_from_file.html">WeightsFromFile</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_x_d_r_data_size_error.html">XDRDataSizeError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception indicating internal XDR error.  <a href="structloos_1_1_x_d_r_data_size_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_x_form.html">XForm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix class for handling coordinate transforms...  <a href="classloos_1_1_x_form.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_x_t_c.html">XTC</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing GROMACS reduced precision, compressed trajectories.  <a href="classloos_1_1_x_t_c.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_x_t_c_writer.html">XTCWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for writing <a class="el" href="classloos_1_1_gromacs.html" title="Implements a GROMACS model file (.gro)">Gromacs</a> <a class="el" href="classloos_1_1_x_t_c.html" title="Class representing GROMACS reduced precision, compressed trajectories.">XTC</a> trajectories.  <a href="classloos_1_1_x_t_c_writer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structloos_1_1_z_slice_selector.html">ZSliceSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Predicate for selecting atoms in a specific range of z values.  <a href="structloos_1_1_z_slice_selector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a10b6afb2e6352a118766ca2826f43dfd" id="r_a10b6afb2e6352a118766ca2826f43dfd"><td class="memItemLeft" align="right" valign="top"><a id="a10b6afb2e6352a118766ca2826f43dfd" name="a10b6afb2e6352a118766ca2826f43dfd"></a>
<a class="el" href="classloos_1_1_math_1_1_matrix.html">typedef</a> boost::unordered_map&lt; int, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>IMap</b></td></tr>
<tr class="separator:a10b6afb2e6352a118766ca2826f43dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14441c8676772c04dc6d08db44887151" id="r_a14441c8676772c04dc6d08db44887151"><td class="memItemLeft" align="right" valign="top"><a id="a14441c8676772c04dc6d08db44887151" name="a14441c8676772c04dc6d08db44887151"></a>
<a class="el" href="classloos_1_1_math_1_1_matrix.html">typedef</a> boost::shared_ptr&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pAtomicGroup</b></td></tr>
<tr class="separator:a14441c8676772c04dc6d08db44887151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a9eac32b9db6b2b15316c5933ab75d" id="r_a62a9eac32b9db6b2b15316c5933ab75d"><td class="memItemLeft" align="right" valign="top"><a id="a62a9eac32b9db6b2b15316c5933ab75d" name="a62a9eac32b9db6b2b15316c5933ab75d"></a>
<a class="el" href="classloos_1_1_math_1_1_matrix.html">typedef</a> double&#160;</td><td class="memItemRight" valign="bottom"><b>greal</b></td></tr>
<tr class="separator:a62a9eac32b9db6b2b15316c5933ab75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d9ad90e3b5d07cf29b9ddf698b6bda8" id="r_a3d9ad90e3b5d07cf29b9ddf698b6bda8"><td class="memItemLeft" align="right" valign="top"><a id="a3d9ad90e3b5d07cf29b9ddf698b6bda8" name="a3d9ad90e3b5d07cf29b9ddf698b6bda8"></a>
<a class="el" href="classloos_1_1_math_1_1_matrix.html">typedef</a> long&#160;</td><td class="memItemRight" valign="bottom"><b>gint</b></td></tr>
<tr class="separator:a3d9ad90e3b5d07cf29b9ddf698b6bda8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9db7c2cd6f381830ee2eafdfdfdf0e4" id="r_aa9db7c2cd6f381830ee2eafdfdfdf0e4"><td class="memItemLeft" align="right" valign="top"><a id="aa9db7c2cd6f381830ee2eafdfdfdf0e4" name="aa9db7c2cd6f381830ee2eafdfdfdf0e4"></a>
<a class="el" href="classloos_1_1_math_1_1_matrix.html">typedef</a> float&#160;</td><td class="memItemRight" valign="bottom"><b>dcd_real</b></td></tr>
<tr class="separator:aa9db7c2cd6f381830ee2eafdfdfdf0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e49cefcdaf7ebc4074701b3575354d" id="r_a23e49cefcdaf7ebc4074701b3575354d"><td class="memItemLeft" align="right" valign="top"><a id="a23e49cefcdaf7ebc4074701b3575354d" name="a23e49cefcdaf7ebc4074701b3575354d"></a>
<a class="el" href="classloos_1_1_math_1_1_matrix.html">typedef</a> double&#160;</td><td class="memItemRight" valign="bottom"><b>dcd_double</b></td></tr>
<tr class="separator:a23e49cefcdaf7ebc4074701b3575354d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc65167090212ee9ef5fbe456664a725" id="r_acc65167090212ee9ef5fbe456664a725"><td class="memItemLeft" align="right" valign="top"><a id="acc65167090212ee9ef5fbe456664a725" name="acc65167090212ee9ef5fbe456664a725"></a>
<a class="el" href="classloos_1_1_math_1_1_matrix.html">typedef</a> <a class="el" href="classloos_1_1_coord.html">Coord</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GCoord</b></td></tr>
<tr class="separator:acc65167090212ee9ef5fbe456664a725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae98ad536c7d55db0777466d2e289ecd9" id="r_ae98ad536c7d55db0777466d2e289ecd9"><td class="memItemLeft" align="right" valign="top"><a id="ae98ad536c7d55db0777466d2e289ecd9" name="ae98ad536c7d55db0777466d2e289ecd9"></a>
<a class="el" href="classloos_1_1_math_1_1_matrix.html">typedef</a> boost::shared_ptr&lt; <a class="el" href="classloos_1_1_coord.html">GCoord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pGCoord</b></td></tr>
<tr class="separator:ae98ad536c7d55db0777466d2e289ecd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cf07772410e906c25f91d8e61cbe4ec" id="r_a6cf07772410e906c25f91d8e61cbe4ec"><td class="memItemLeft" align="right" valign="top"><a id="a6cf07772410e906c25f91d8e61cbe4ec" name="a6cf07772410e906c25f91d8e61cbe4ec"></a>
<a class="el" href="classloos_1_1_math_1_1_matrix.html">typedef</a> boost::shared_ptr&lt; <a class="el" href="classloos_1_1_atom.html">Atom</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pAtom</b></td></tr>
<tr class="separator:a6cf07772410e906c25f91d8e61cbe4ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e09291871df43363ebd6c1208b3c6b3" id="r_a7e09291871df43363ebd6c1208b3c6b3"><td class="memItemLeft" align="right" valign="top"><a id="a7e09291871df43363ebd6c1208b3c6b3" name="a7e09291871df43363ebd6c1208b3c6b3"></a>
<a class="el" href="classloos_1_1_math_1_1_matrix.html">typedef</a> boost::shared_ptr&lt; <a class="el" href="classloos_1_1_trajectory.html">Trajectory</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pTraj</b></td></tr>
<tr class="separator:a7e09291871df43363ebd6c1208b3c6b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71db4ff51b50bf97153cd5066169f9c6" id="r_a71db4ff51b50bf97153cd5066169f9c6"><td class="memItemLeft" align="right" valign="top"><a id="a71db4ff51b50bf97153cd5066169f9c6" name="a71db4ff51b50bf97153cd5066169f9c6"></a>
<a class="el" href="classloos_1_1_math_1_1_matrix.html">typedef</a> boost::shared_ptr&lt; <a class="el" href="classloos_1_1_d_c_d.html">DCD</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pDCD</b></td></tr>
<tr class="separator:a71db4ff51b50bf97153cd5066169f9c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5612443977ee5f80750d5942698526f5" id="r_a5612443977ee5f80750d5942698526f5"><td class="memItemLeft" align="right" valign="top"><a id="a5612443977ee5f80750d5942698526f5" name="a5612443977ee5f80750d5942698526f5"></a>
<a class="el" href="classloos_1_1_math_1_1_matrix.html">typedef</a> boost::shared_ptr&lt; <a class="el" href="classloos_1_1_amber_traj.html">AmberTraj</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pAmberTraj</b></td></tr>
<tr class="separator:a5612443977ee5f80750d5942698526f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1841378484f3acf8e2369ecba7d11b" id="r_a8b1841378484f3acf8e2369ecba7d11b"><td class="memItemLeft" align="right" valign="top"><a id="a8b1841378484f3acf8e2369ecba7d11b" name="a8b1841378484f3acf8e2369ecba7d11b"></a>
<a class="el" href="classloos_1_1_math_1_1_matrix.html">typedef</a> boost::shared_ptr&lt; <a class="el" href="classloos_1_1_amber_netcdf.html">AmberNetcdf</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pAmberNetcdf</b></td></tr>
<tr class="separator:a8b1841378484f3acf8e2369ecba7d11b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c259756e217d4524c11f9fa9a543d09" id="r_a1c259756e217d4524c11f9fa9a543d09"><td class="memItemLeft" align="right" valign="top"><a id="a1c259756e217d4524c11f9fa9a543d09" name="a1c259756e217d4524c11f9fa9a543d09"></a>
<a class="el" href="classloos_1_1_math_1_1_matrix.html">typedef</a> boost::shared_ptr&lt; <a class="el" href="classloos_1_1_c_c_p_d_b.html">CCPDB</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pCCPDB</b></td></tr>
<tr class="separator:a1c259756e217d4524c11f9fa9a543d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a35e716ca8ebbfbb41c1103d226b23c" id="r_a7a35e716ca8ebbfbb41c1103d226b23c"><td class="memItemLeft" align="right" valign="top"><a id="a7a35e716ca8ebbfbb41c1103d226b23c" name="a7a35e716ca8ebbfbb41c1103d226b23c"></a>
<a class="el" href="classloos_1_1_math_1_1_matrix.html">typedef</a> boost::shared_ptr&lt; <a class="el" href="classloos_1_1_tinker_arc.html">TinkerArc</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pTinkerArc</b></td></tr>
<tr class="separator:a7a35e716ca8ebbfbb41c1103d226b23c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f0da9847b65f7165cc73f69bcb7eebd" id="r_a7f0da9847b65f7165cc73f69bcb7eebd"><td class="memItemLeft" align="right" valign="top"><a id="a7f0da9847b65f7165cc73f69bcb7eebd" name="a7f0da9847b65f7165cc73f69bcb7eebd"></a>
<a class="el" href="classloos_1_1_math_1_1_matrix.html">typedef</a> boost::shared_ptr&lt; <a class="el" href="classloos_1_1_p_d_b_traj.html">PDBTraj</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pPDBTraj</b></td></tr>
<tr class="separator:a7f0da9847b65f7165cc73f69bcb7eebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6003eff82bee37538bf33bbf61d13d05" id="r_a6003eff82bee37538bf33bbf61d13d05"><td class="memItemLeft" align="right" valign="top"><a id="a6003eff82bee37538bf33bbf61d13d05" name="a6003eff82bee37538bf33bbf61d13d05"></a>
<a class="el" href="classloos_1_1_math_1_1_matrix.html">typedef</a> boost::shared_ptr&lt; <a class="el" href="classloos_1_1_x_t_c.html">XTC</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pXTC</b></td></tr>
<tr class="separator:a6003eff82bee37538bf33bbf61d13d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2160bb5fe891e3a23442652770fed1cb" id="r_a2160bb5fe891e3a23442652770fed1cb"><td class="memItemLeft" align="right" valign="top"><a id="a2160bb5fe891e3a23442652770fed1cb" name="a2160bb5fe891e3a23442652770fed1cb"></a>
<a class="el" href="classloos_1_1_math_1_1_matrix.html">typedef</a> boost::shared_ptr&lt; <a class="el" href="classloos_1_1_t_r_r.html">TRR</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pTRR</b></td></tr>
<tr class="separator:a2160bb5fe891e3a23442652770fed1cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadade194a2445d7ef5808201dd33ab5a" id="r_aadade194a2445d7ef5808201dd33ab5a"><td class="memItemLeft" align="right" valign="top"><a id="aadade194a2445d7ef5808201dd33ab5a" name="aadade194a2445d7ef5808201dd33ab5a"></a>
<a class="el" href="classloos_1_1_math_1_1_matrix.html">typedef</a> boost::shared_ptr&lt; <a class="el" href="classloos_1_1_trajectory_writer.html">TrajectoryWriter</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pTrajectoryWriter</b></td></tr>
<tr class="separator:aadade194a2445d7ef5808201dd33ab5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad26d06605ac7fa467aebda6a9403a1f4" id="r_ad26d06605ac7fa467aebda6a9403a1f4"><td class="memItemLeft" align="right" valign="top"><a id="ad26d06605ac7fa467aebda6a9403a1f4" name="ad26d06605ac7fa467aebda6a9403a1f4"></a>
<a class="el" href="classloos_1_1_math_1_1_matrix.html">typedef</a> boost::shared_ptr&lt; <a class="el" href="classloos_1_1_p_d_b.html">PDB</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pPDB</b></td></tr>
<tr class="separator:ad26d06605ac7fa467aebda6a9403a1f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cdadc7bbce79292e8587fff5673628d" id="r_a3cdadc7bbce79292e8587fff5673628d"><td class="memItemLeft" align="right" valign="top"><a id="a3cdadc7bbce79292e8587fff5673628d" name="a3cdadc7bbce79292e8587fff5673628d"></a>
<a class="el" href="classloos_1_1_math_1_1_matrix.html">typedef</a> boost::shared_ptr&lt; <a class="el" href="classloos_1_1_p_s_f.html">PSF</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pPSF</b></td></tr>
<tr class="separator:a3cdadc7bbce79292e8587fff5673628d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad06ce169a29685220e441574c09f9ec5" id="r_ad06ce169a29685220e441574c09f9ec5"><td class="memItemLeft" align="right" valign="top"><a id="ad06ce169a29685220e441574c09f9ec5" name="ad06ce169a29685220e441574c09f9ec5"></a>
<a class="el" href="classloos_1_1_math_1_1_matrix.html">typedef</a> boost::shared_ptr&lt; <a class="el" href="classloos_1_1_amber.html">Amber</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pAmber</b></td></tr>
<tr class="separator:ad06ce169a29685220e441574c09f9ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb56aad450f747e11291af29bd32548" id="r_afdb56aad450f747e11291af29bd32548"><td class="memItemLeft" align="right" valign="top"><a id="afdb56aad450f747e11291af29bd32548" name="afdb56aad450f747e11291af29bd32548"></a>
<a class="el" href="classloos_1_1_math_1_1_matrix.html">typedef</a> boost::shared_ptr&lt; <a class="el" href="classloos_1_1_amber_rst.html">AmberRst</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pAmberRst</b></td></tr>
<tr class="separator:afdb56aad450f747e11291af29bd32548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac24e9a289011d290b81f2c61cc89c96d" id="r_ac24e9a289011d290b81f2c61cc89c96d"><td class="memItemLeft" align="right" valign="top"><a id="ac24e9a289011d290b81f2c61cc89c96d" name="ac24e9a289011d290b81f2c61cc89c96d"></a>
<a class="el" href="classloos_1_1_math_1_1_matrix.html">typedef</a> boost::shared_ptr&lt; <a class="el" href="classloos_1_1_tinker_x_y_z.html">TinkerXYZ</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pTinkerXYZ</b></td></tr>
<tr class="separator:ac24e9a289011d290b81f2c61cc89c96d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c77a14a66259e1993361e831c2878a2" id="r_a5c77a14a66259e1993361e831c2878a2"><td class="memItemLeft" align="right" valign="top"><a id="a5c77a14a66259e1993361e831c2878a2" name="a5c77a14a66259e1993361e831c2878a2"></a>
<a class="el" href="classloos_1_1_math_1_1_matrix.html">typedef</a> boost::shared_ptr&lt; <a class="el" href="classloos_1_1_gromacs.html">Gromacs</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pGromacs</b></td></tr>
<tr class="separator:a5c77a14a66259e1993361e831c2878a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ee08574d2708ea67e46c23f3555936" id="r_a28ee08574d2708ea67e46c23f3555936"><td class="memItemLeft" align="right" valign="top"><a id="a28ee08574d2708ea67e46c23f3555936" name="a28ee08574d2708ea67e46c23f3555936"></a>
<a class="el" href="classloos_1_1_math_1_1_matrix.html">typedef</a> boost::shared_ptr&lt; <a class="el" href="classloos_1_1_c_h_a_r_m_m.html">CHARMM</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pCHARMM</b></td></tr>
<tr class="separator:a28ee08574d2708ea67e46c23f3555936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2231239c6c78021cb3b0e39437f4e0e2" id="r_a2231239c6c78021cb3b0e39437f4e0e2"><td class="memItemLeft" align="right" valign="top"><a id="a2231239c6c78021cb3b0e39437f4e0e2" name="a2231239c6c78021cb3b0e39437f4e0e2"></a>
<a class="el" href="classloos_1_1_math_1_1_matrix.html">typedef</a> boost::shared_ptr&lt; <a class="el" href="classloos_1_1_m_m_c_i_f.html">MMCIF</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pMMCIF</b></td></tr>
<tr class="separator:a2231239c6c78021cb3b0e39437f4e0e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5399f8b1ce8f6cd4f002e3fe5b1e2966" id="r_a5399f8b1ce8f6cd4f002e3fe5b1e2966"><td class="memItemLeft" align="right" valign="top"><a id="a5399f8b1ce8f6cd4f002e3fe5b1e2966" name="a5399f8b1ce8f6cd4f002e3fe5b1e2966"></a>
<a class="el" href="classloos_1_1_math_1_1_matrix.html">typedef</a> <a class="el" href="classloos_1_1_math_1_1_matrix.html">Math::Matrix</a>&lt; float, <a class="el" href="classloos_1_1_math_1_1_col_major.html">Math::ColMajor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>RealMatrix</b></td></tr>
<tr class="separator:a5399f8b1ce8f6cd4f002e3fe5b1e2966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02a6cb7a9380eb98800a41814332e31" id="r_ae02a6cb7a9380eb98800a41814332e31"><td class="memItemLeft" align="right" valign="top"><a id="ae02a6cb7a9380eb98800a41814332e31" name="ae02a6cb7a9380eb98800a41814332e31"></a>
<a class="el" href="classloos_1_1_math_1_1_matrix.html">typedef</a> <a class="el" href="classloos_1_1_math_1_1_matrix.html">Math::Matrix</a>&lt; double, <a class="el" href="classloos_1_1_math_1_1_col_major.html">Math::ColMajor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>DoubleMatrix</b></td></tr>
<tr class="separator:ae02a6cb7a9380eb98800a41814332e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655584490721f039229fcb21c31300a5" id="r_a655584490721f039229fcb21c31300a5"><td class="memItemLeft" align="right" valign="top"><a id="a655584490721f039229fcb21c31300a5" name="a655584490721f039229fcb21c31300a5"></a>
<a class="el" href="classloos_1_1_math_1_1_matrix.html">typedef</a> <a class="el" href="classloos_1_1_time_series.html">TimeSeries</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>dTimeSeries</b></td></tr>
<tr class="separator:a655584490721f039229fcb21c31300a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a862847bc2f540b9992da04a1a8a1115f" id="r_a862847bc2f540b9992da04a1a8a1115f"><td class="memItemLeft" align="right" valign="top"><a id="a862847bc2f540b9992da04a1a8a1115f" name="a862847bc2f540b9992da04a1a8a1115f"></a>
<a class="el" href="classloos_1_1_math_1_1_matrix.html">typedef</a> <a class="el" href="classloos_1_1_time_series.html">TimeSeries</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>fTimeSeries</b></td></tr>
<tr class="separator:a862847bc2f540b9992da04a1a8a1115f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac371342cdaaeea9ac9c1cbf89af5792f" id="r_ac371342cdaaeea9ac9c1cbf89af5792f"><td class="memItemLeft" align="right" valign="top"><a id="ac371342cdaaeea9ac9c1cbf89af5792f" name="ac371342cdaaeea9ac9c1cbf89af5792f"></a>
<a class="el" href="classloos_1_1_math_1_1_matrix.html">typedef</a> boost::mt19937&#160;</td><td class="memItemRight" valign="bottom"><b>base_generator_type</b></td></tr>
<tr class="separator:ac371342cdaaeea9ac9c1cbf89af5792f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb4c317197fd53bdf8856e91988a9b0b" id="r_adb4c317197fd53bdf8856e91988a9b0b"><td class="memItemLeft" align="right" valign="top"><a id="adb4c317197fd53bdf8856e91988a9b0b" name="adb4c317197fd53bdf8856e91988a9b0b"></a>
<a class="el" href="classloos_1_1_math_1_1_matrix.html">typedef</a> <a class="el" href="classloos_1_1_matrix44.html">Matrix44</a>&lt; greal &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GMatrix</b></td></tr>
<tr class="separator:adb4c317197fd53bdf8856e91988a9b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a49641765fa93b77284181d6ee83eea86" id="r_a49641765fa93b77284181d6ee83eea86"><td class="memItemLeft" align="right" valign="top"><a id="a49641765fa93b77284181d6ee83eea86" name="a49641765fa93b77284181d6ee83eea86"></a>
boost::tuple&lt; std::vector&lt; <a class="el" href="classloos_1_1_x_form.html">XForm</a> &gt;, greal, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>iterativeAlignment</b> (alignment::vecMatrix &amp;<a class="el" href="classloos_1_1_math_1_1_matrix.html">ensemble</a>, greal threshold, int <a class="el" href="classloos_1_1_math_1_1_matrix.html">maxiter</a>)</td></tr>
<tr class="separator:a49641765fa93b77284181d6ee83eea86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a832649f67b5fad01e4c3f5102855ae30" id="r_a832649f67b5fad01e4c3f5102855ae30"><td class="memItemLeft" align="right" valign="top"><a id="a832649f67b5fad01e4c3f5102855ae30" name="a832649f67b5fad01e4c3f5102855ae30"></a>
boost::tuple&lt; std::vector&lt; <a class="el" href="classloos_1_1_x_form.html">XForm</a> &gt;, greal, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>iterativeAlignment</b> (std::vector&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt; &amp;<a class="el" href="classloos_1_1_math_1_1_matrix.html">ensemble</a>, greal threshold, int <a class="el" href="classloos_1_1_math_1_1_matrix.html">maxiter</a>)</td></tr>
<tr class="separator:a832649f67b5fad01e4c3f5102855ae30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab42aeab4c92169da3571c75d3f035ad5" id="r_ab42aeab4c92169da3571c75d3f035ad5"><td class="memItemLeft" align="right" valign="top">boost::tuple&lt; std::vector&lt; <a class="el" href="classloos_1_1_x_form.html">XForm</a> &gt;, greal, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab42aeab4c92169da3571c75d3f035ad5">iterativeAlignment</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;model, pTraj &amp;traj, const std::vector&lt; uint &gt; &amp;frame_indices, greal threshold=1<a class="el" href="classloos_1_1_math_1_1_matrix.html">e</a>-6, int <a class="el" href="classloos_1_1_math_1_1_matrix.html">maxiter</a>=1000)</td></tr>
<tr class="memdesc:ab42aeab4c92169da3571c75d3f035ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute an iterative superposition by reading in frames from the <a class="el" href="classloos_1_1_trajectory.html" title="Base-class for polymorphic trajectories.">Trajectory</a>.  <br /></td></tr>
<tr class="separator:ab42aeab4c92169da3571c75d3f035ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0eb966a6f433cbf170fbfe97dbc1041" id="r_aa0eb966a6f433cbf170fbfe97dbc1041"><td class="memItemLeft" align="right" valign="top"><a id="aa0eb966a6f433cbf170fbfe97dbc1041" name="aa0eb966a6f433cbf170fbfe97dbc1041"></a>
boost::tuple&lt; std::vector&lt; <a class="el" href="classloos_1_1_x_form.html">XForm</a> &gt;, greal, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>iterativeAlignment</b> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;g, pTraj &amp;traj, greal threshold, int <a class="el" href="classloos_1_1_math_1_1_matrix.html">maxiter</a>)</td></tr>
<tr class="separator:aa0eb966a6f433cbf170fbfe97dbc1041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af60e58ede81cd383ae1dab79df2b309f" id="r_af60e58ede81cd383ae1dab79df2b309f"><td class="memItemLeft" align="right" valign="top"><a id="af60e58ede81cd383ae1dab79df2b309f" name="af60e58ede81cd383ae1dab79df2b309f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isFileNetCDF</b> (const std::string &amp;fname)</td></tr>
<tr class="memdesc:af60e58ede81cd383ae1dab79df2b309f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the file is a NetCDF file. <br /></td></tr>
<tr class="separator:af60e58ede81cd383ae1dab79df2b309f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c25f1b6fdc4247d26e71ba3db2da2f" id="r_ac2c25f1b6fdc4247d26e71ba3db2da2f"><td class="memItemLeft" align="right" valign="top"><a id="ac2c25f1b6fdc4247d26e71ba3db2da2f" name="ac2c25f1b6fdc4247d26e71ba3db2da2f"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classloos_1_1_atom.html">loos::Atom</a> &amp;a)</td></tr>
<tr class="separator:ac2c25f1b6fdc4247d26e71ba3db2da2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2567359abda91586ae2750e6e2d1d8" id="r_ace2567359abda91586ae2750e6e2d1d8"><td class="memItemLeft" align="right" valign="top"><a id="ace2567359abda91586ae2750e6e2d1d8" name="ace2567359abda91586ae2750e6e2d1d8"></a>
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const pAtom &amp;lhs, const pAtom &amp;rhs)</td></tr>
<tr class="separator:ace2567359abda91586ae2750e6e2d1d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30e6726ac3e8f663fddbd7be4fa472bd" id="r_a30e6726ac3e8f663fddbd7be4fa472bd"><td class="memItemLeft" align="right" valign="top"><a id="a30e6726ac3e8f663fddbd7be4fa472bd" name="a30e6726ac3e8f663fddbd7be4fa472bd"></a>
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const pAtom &amp;lhs, const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;rhs)</td></tr>
<tr class="separator:a30e6726ac3e8f663fddbd7be4fa472bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2484150f3d6527acdff31735cdda10" id="r_adb2484150f3d6527acdff31735cdda10"><td class="memItemLeft" align="right" valign="top"><a id="adb2484150f3d6527acdff31735cdda10" name="adb2484150f3d6527acdff31735cdda10"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;grp)</td></tr>
<tr class="separator:adb2484150f3d6527acdff31735cdda10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce914a61c5001a5a966864f758630ca" id="r_a8ce914a61c5001a5a966864f758630ca"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ce914a61c5001a5a966864f758630ca">deduceAtomicNumberFromMass</a> (const double mass, const double tolerance=0.1)</td></tr>
<tr class="memdesc:a8ce914a61c5001a5a966864f758630ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce an atomic number from the mass.  <br /></td></tr>
<tr class="separator:a8ce914a61c5001a5a966864f758630ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a038aca48d2d1e2c727b95551ea3433c0" id="r_a038aca48d2d1e2c727b95551ea3433c0"><td class="memItemLeft" align="right" valign="top"><a id="a038aca48d2d1e2c727b95551ea3433c0" name="a038aca48d2d1e2c727b95551ea3433c0"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>deduceElementNameFromMass</b> (const double mass, const double tolerance)</td></tr>
<tr class="separator:a038aca48d2d1e2c727b95551ea3433c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8978cad46e005463a8b6021356ed83b" id="r_ad8978cad46e005463a8b6021356ed83b"><td class="memItemLeft" align="right" valign="top"><a id="ad8978cad46e005463a8b6021356ed83b" name="ad8978cad46e005463a8b6021356ed83b"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>deduceMassFromAtomicNumber</b> (const unsigned int number)</td></tr>
<tr class="memdesc:ad8978cad46e005463a8b6021356ed83b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce a mass from the atomic number. <br /></td></tr>
<tr class="separator:ad8978cad46e005463a8b6021356ed83b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad172cde7ba10cd0378d767a9c5ece776" id="r_ad172cde7ba10cd0378d767a9c5ece776"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> T &gt; </td></tr>
<tr class="memitem:ad172cde7ba10cd0378d767a9c5ece776"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classloos_1_1_coord.html">Coord</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad172cde7ba10cd0378d767a9c5ece776">operator*</a> (const <a class="el" href="classloos_1_1_matrix44.html">Matrix44</a>&lt; T &gt; &amp;, const <a class="el" href="classloos_1_1_coord.html">Coord</a>&lt; T &gt; &amp;)</td></tr>
<tr class="separator:ad172cde7ba10cd0378d767a9c5ece776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e5cf3887d2df87d0806a6c79c9d8627" id="r_a9e5cf3887d2df87d0806a6c79c9d8627"><td class="memItemLeft" align="right" valign="top"><a id="a9e5cf3887d2df87d0806a6c79c9d8627" name="a9e5cf3887d2df87d0806a6c79c9d8627"></a>
double *&#160;</td><td class="memItemRight" valign="bottom"><b>gridify</b> (<a class="el" href="classloos_1_1_d_c_d.html">DCD</a> &amp;, double *, double *, int[], const std::vector&lt; int &gt;, int, int, double)</td></tr>
<tr class="separator:a9e5cf3887d2df87d0806a6c79c9d8627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe25ba2b9027123aca28176782570862" id="r_abe25ba2b9027123aca28176782570862"><td class="memItemLeft" align="right" valign="top"><a id="abe25ba2b9027123aca28176782570862" name="abe25ba2b9027123aca28176782570862"></a>
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><b>averageStructure</b> (const std::vector&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt; &amp;<a class="el" href="classloos_1_1_math_1_1_matrix.html">ensemble</a>)</td></tr>
<tr class="memdesc:abe25ba2b9027123aca28176782570862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the average structure of a set of <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually)">AtomicGroup</a> objects. <br /></td></tr>
<tr class="separator:abe25ba2b9027123aca28176782570862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10ec538bd0a45ef4543c60489fb6a74" id="r_aa10ec538bd0a45ef4543c60489fb6a74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa10ec538bd0a45ef4543c60489fb6a74">averageStructure</a> (const std::vector&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt; &amp;<a class="el" href="classloos_1_1_math_1_1_matrix.html">ensemble</a>, const std::vector&lt; <a class="el" href="classloos_1_1_x_form.html">XForm</a> &gt; &amp;<a class="el" href="classloos_1_1_math_1_1_matrix.html">xforms</a>)</td></tr>
<tr class="memdesc:aa10ec538bd0a45ef4543c60489fb6a74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the average structure of a set of <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually)">AtomicGroup</a> objects.  <br /></td></tr>
<tr class="separator:aa10ec538bd0a45ef4543c60489fb6a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a145b1950c29d680031aaba768f133ce0" id="r_a145b1950c29d680031aaba768f133ce0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a145b1950c29d680031aaba768f133ce0">averageStructure</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;, const std::vector&lt; <a class="el" href="classloos_1_1_x_form.html">XForm</a> &gt; &amp;, pTraj &amp;traj, const std::vector&lt; uint &gt; &amp;indices)</td></tr>
<tr class="memdesc:a145b1950c29d680031aaba768f133ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the average structure from a trajectory reading only certain frames.  <br /></td></tr>
<tr class="separator:a145b1950c29d680031aaba768f133ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50aefac013fa449999f74fa4e0df8b55" id="r_a50aefac013fa449999f74fa4e0df8b55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50aefac013fa449999f74fa4e0df8b55">averageStructure</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;, const std::vector&lt; <a class="el" href="classloos_1_1_x_form.html">XForm</a> &gt; &amp;, pTraj &amp;traj)</td></tr>
<tr class="memdesc:a50aefac013fa449999f74fa4e0df8b55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the average structure using all frames in a trajectory.  <br /></td></tr>
<tr class="separator:a50aefac013fa449999f74fa4e0df8b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87fa637f8cfa6289d84f12a818071c27" id="r_a87fa637f8cfa6289d84f12a818071c27"><td class="memItemLeft" align="right" valign="top"><a id="a87fa637f8cfa6289d84f12a818071c27" name="a87fa637f8cfa6289d84f12a818071c27"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>applyTransforms</b> (std::vector&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt; &amp;<a class="el" href="classloos_1_1_math_1_1_matrix.html">ensemble</a>, std::vector&lt; <a class="el" href="classloos_1_1_x_form.html">XForm</a> &gt; &amp;<a class="el" href="classloos_1_1_math_1_1_matrix.html">xforms</a>)</td></tr>
<tr class="separator:a87fa637f8cfa6289d84f12a818071c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b08e1ea35c0b41c4ef7c023ddc66008" id="r_a0b08e1ea35c0b41c4ef7c023ddc66008"><td class="memItemLeft" align="right" valign="top"><a id="a0b08e1ea35c0b41c4ef7c023ddc66008" name="a0b08e1ea35c0b41c4ef7c023ddc66008"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>readTrajectory</b> (std::vector&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt; &amp;<a class="el" href="classloos_1_1_math_1_1_matrix.html">ensemble</a>, const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;model, pTraj trajectory)</td></tr>
<tr class="separator:a0b08e1ea35c0b41c4ef7c023ddc66008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78afa41f5adfbea531e21eb6619b3ac5" id="r_a78afa41f5adfbea531e21eb6619b3ac5"><td class="memItemLeft" align="right" valign="top"><a id="a78afa41f5adfbea531e21eb6619b3ac5" name="a78afa41f5adfbea531e21eb6619b3ac5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>readTrajectory</b> (std::vector&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt; &amp;<a class="el" href="classloos_1_1_math_1_1_matrix.html">ensemble</a>, const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;model, pTraj trajectory, std::vector&lt; uint &gt; &amp;frames)</td></tr>
<tr class="separator:a78afa41f5adfbea531e21eb6619b3ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab105c97e5ba3247de8ade1fad86e5708" id="r_ab105c97e5ba3247de8ade1fad86e5708"><td class="memItemLeft" align="right" valign="top"><a id="ab105c97e5ba3247de8ade1fad86e5708" name="ab105c97e5ba3247de8ade1fad86e5708"></a>
<a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><b>extractCoords</b> (const std::vector&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt; &amp;<a class="el" href="classloos_1_1_math_1_1_matrix.html">ensemble</a>)</td></tr>
<tr class="separator:ab105c97e5ba3247de8ade1fad86e5708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52bea8219aacef9d44fdafa407be8c50" id="r_a52bea8219aacef9d44fdafa407be8c50"><td class="memItemLeft" align="right" valign="top"><a id="a52bea8219aacef9d44fdafa407be8c50" name="a52bea8219aacef9d44fdafa407be8c50"></a>
<a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><b>extractCoords</b> (const std::vector&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt; &amp;<a class="el" href="classloos_1_1_math_1_1_matrix.html">ensemble</a>, const std::vector&lt; <a class="el" href="classloos_1_1_x_form.html">XForm</a> &gt; &amp;<a class="el" href="classloos_1_1_math_1_1_matrix.html">xforms</a>)</td></tr>
<tr class="separator:a52bea8219aacef9d44fdafa407be8c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee39a071d0643188f73b398af04c5d7" id="r_a0ee39a071d0643188f73b398af04c5d7"><td class="memItemLeft" align="right" valign="top"><a id="a0ee39a071d0643188f73b398af04c5d7" name="a0ee39a071d0643188f73b398af04c5d7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>subtractAverage</b> (<a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a> &amp;M)</td></tr>
<tr class="separator:a0ee39a071d0643188f73b398af04c5d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34932a929bc0953556a35766c9989471" id="r_a34932a929bc0953556a35766c9989471"><td class="memItemLeft" align="right" valign="top">boost::tuple&lt; <a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a>, <a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a>, <a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34932a929bc0953556a35766c9989471">svd</a> (std::vector&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt; &amp;<a class="el" href="classloos_1_1_math_1_1_matrix.html">ensemble</a>, const bool <a class="el" href="classloos_1_1_math_1_1_matrix.html">align</a>=<a class="el" href="classloos_1_1_math_1_1_matrix.html">true</a>)</td></tr>
<tr class="memdesc:a34932a929bc0953556a35766c9989471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the SVD of an ensemble with optional alignment (note RSVs returned are transposed)  <br /></td></tr>
<tr class="separator:a34932a929bc0953556a35766c9989471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e43cc68b6dd5c4088ba26b5b6e1585" id="r_a45e43cc68b6dd5c4088ba26b5b6e1585"><td class="memItemLeft" align="right" valign="top"><a id="a45e43cc68b6dd5c4088ba26b5b6e1585" name="a45e43cc68b6dd5c4088ba26b5b6e1585"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>appendCoords</b> (std::vector&lt; std::vector&lt; double &gt; &gt; &amp;M, <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;model, pTraj &amp;traj, const std::vector&lt; uint &gt; &amp;indices, const bool <a class="el" href="classloos_1_1_math_1_1_matrix.html">updates</a>=false)</td></tr>
<tr class="separator:a45e43cc68b6dd5c4088ba26b5b6e1585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa577aee0e745597b4ed2ca0588c4be" id="r_a4aa577aee0e745597b4ed2ca0588c4be"><td class="memItemLeft" align="right" valign="top"><a id="a4aa577aee0e745597b4ed2ca0588c4be" name="a4aa577aee0e745597b4ed2ca0588c4be"></a>
std::vector&lt; std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>readCoords</b> (<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;model, pTraj &amp;traj, const std::vector&lt; uint &gt; &amp;indices, const bool <a class="el" href="classloos_1_1_math_1_1_matrix.html">updates</a>=false)</td></tr>
<tr class="separator:a4aa577aee0e745597b4ed2ca0588c4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addba2db09fd04a563c820e465b4aa6c6" id="r_addba2db09fd04a563c820e465b4aa6c6"><td class="memItemLeft" align="right" valign="top"><a id="addba2db09fd04a563c820e465b4aa6c6" name="addba2db09fd04a563c820e465b4aa6c6"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="structloos_1_1_bound_fmt.html">BoundFmt</a> &amp;<a class="el" href="classloos_1_1_math_1_1_matrix.html">bf</a>)</td></tr>
<tr class="memdesc:addba2db09fd04a563c820e465b4aa6c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the output with the specified formatter. <br /></td></tr>
<tr class="separator:addba2db09fd04a563c820e465b4aa6c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5787a9c94567691f2bc0e5362320a92c" id="r_a5787a9c94567691f2bc0e5362320a92c"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5787a9c94567691f2bc0e5362320a92c">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classloos_1_1_gromacs.html">Gromacs</a> &amp;g)</td></tr>
<tr class="memdesc:a5787a9c94567691f2bc0e5362320a92c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the group as a GRO...  <br /></td></tr>
<tr class="separator:a5787a9c94567691f2bc0e5362320a92c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a934b70913b38a1bb2aa4c0fecf32d0" id="r_a3a934b70913b38a1bb2aa4c0fecf32d0"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classloos_1_1_math_1_1_matrix.html">uint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a934b70913b38a1bb2aa4c0fecf32d0">parseIndexRange</a> (<a class="el" href="classloos_1_1_math_1_1_matrix.html">const</a> std::string &amp;<a class="el" href="classloos_1_1_math_1_1_matrix.html">input</a>, <a class="el" href="classloos_1_1_math_1_1_matrix.html">const</a> <a class="el" href="classloos_1_1_math_1_1_matrix.html">uint</a> maxsize)</td></tr>
<tr class="memdesc:a3a934b70913b38a1bb2aa4c0fecf32d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use boost::Spirit to parse a new-style range list.  <br /></td></tr>
<tr class="separator:a3a934b70913b38a1bb2aa4c0fecf32d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab94d3d8491667d11372759f55ec5bd23" id="r_ab94d3d8491667d11372759f55ec5bd23"><td class="memItemLeft" align="right" valign="top"><a id="ab94d3d8491667d11372759f55ec5bd23" name="ab94d3d8491667d11372759f55ec5bd23"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classloos_1_1_kernel.html">Kernel</a> &amp;k)</td></tr>
<tr class="separator:ab94d3d8491667d11372759f55ec5bd23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac456480b8f3035e850f6e3d48491f24d" id="r_ac456480b8f3035e850f6e3d48491f24d"><td class="memTemplParams" colspan="2"><a id="ac456480b8f3035e850f6e3d48491f24d" name="ac456480b8f3035e850f6e3d48491f24d"></a>
template&lt;<a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> T &gt; </td></tr>
<tr class="memitem:ac456480b8f3035e850f6e3d48491f24d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classloos_1_1_timer.html">Timer</a>&lt; T &gt; &amp;t)</td></tr>
<tr class="separator:ac456480b8f3035e850f6e3d48491f24d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe9ddb6cf8a12a14d87d26b4a443446" id="r_a1fe9ddb6cf8a12a14d87d26b4a443446"><td class="memTemplParams" colspan="2"><a id="a1fe9ddb6cf8a12a14d87d26b4a443446" name="a1fe9ddb6cf8a12a14d87d26b4a443446"></a>
template&lt;<a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> T , <a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> P , <a class="el" href="classloos_1_1_math_1_1_matrix.html">template</a>&lt; <a class="el" href="classloos_1_1_math_1_1_matrix.html">typename</a> &gt; <a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> S&gt; </td></tr>
<tr class="memitem:a1fe9ddb6cf8a12a14d87d26b4a443446"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classloos_1_1_math_1_1_matrix.html">Math::Matrix</a>&lt; T, P, S &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>readAsciiMatrix</b> (std::istream &amp;is)</td></tr>
<tr class="memdesc:a1fe9ddb6cf8a12a14d87d26b4a443446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read in a matrix from a stream returning a newly created matrix. <br /></td></tr>
<tr class="separator:a1fe9ddb6cf8a12a14d87d26b4a443446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e01762bdfa3c9270476cac1bed6eb06" id="r_a4e01762bdfa3c9270476cac1bed6eb06"><td class="memTemplParams" colspan="2"><a id="a4e01762bdfa3c9270476cac1bed6eb06" name="a4e01762bdfa3c9270476cac1bed6eb06"></a>
template&lt;<a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> T , <a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> P , <a class="el" href="classloos_1_1_math_1_1_matrix.html">template</a>&lt; <a class="el" href="classloos_1_1_math_1_1_matrix.html">typename</a> &gt; <a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> S&gt; </td></tr>
<tr class="memitem:a4e01762bdfa3c9270476cac1bed6eb06"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>readAsciiMatrix</b> (std::istream &amp;is, <a class="el" href="classloos_1_1_math_1_1_matrix.html">Math::Matrix</a>&lt; T, P, S &gt; &amp;M)</td></tr>
<tr class="memdesc:a4e01762bdfa3c9270476cac1bed6eb06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read in a matrix from a stream storing it in the specified matrix. <br /></td></tr>
<tr class="separator:a4e01762bdfa3c9270476cac1bed6eb06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a651ece598340c91ec015a5daf0656477" id="r_a651ece598340c91ec015a5daf0656477"><td class="memTemplParams" colspan="2"><a id="a651ece598340c91ec015a5daf0656477" name="a651ece598340c91ec015a5daf0656477"></a>
template&lt;<a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> T , <a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> P , <a class="el" href="classloos_1_1_math_1_1_matrix.html">template</a>&lt; <a class="el" href="classloos_1_1_math_1_1_matrix.html">typename</a> &gt; <a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> S&gt; </td></tr>
<tr class="memitem:a651ece598340c91ec015a5daf0656477"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classloos_1_1_math_1_1_matrix.html">Math::Matrix</a>&lt; T, P, S &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>readAsciiMatrix</b> (const std::string &amp;fname)</td></tr>
<tr class="memdesc:a651ece598340c91ec015a5daf0656477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read in a matrix from a file returning a newly created matrix. <br /></td></tr>
<tr class="separator:a651ece598340c91ec015a5daf0656477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e77d0692564a911b561299a64fdf7f6" id="r_a6e77d0692564a911b561299a64fdf7f6"><td class="memTemplParams" colspan="2"><a id="a6e77d0692564a911b561299a64fdf7f6" name="a6e77d0692564a911b561299a64fdf7f6"></a>
template&lt;<a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> T , <a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> P , <a class="el" href="classloos_1_1_math_1_1_matrix.html">template</a>&lt; <a class="el" href="classloos_1_1_math_1_1_matrix.html">typename</a> &gt; <a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> S&gt; </td></tr>
<tr class="memitem:a6e77d0692564a911b561299a64fdf7f6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>readAsciiMatrix</b> (const std::string &amp;fname, <a class="el" href="classloos_1_1_math_1_1_matrix.html">Math::Matrix</a>&lt; T, P, S &gt; &amp;M)</td></tr>
<tr class="memdesc:a6e77d0692564a911b561299a64fdf7f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read in a matrix from a file storing it in the specified matrix. <br /></td></tr>
<tr class="separator:a6e77d0692564a911b561299a64fdf7f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09efd2e63b9afd3800b7776f6dc84a6e" id="r_a09efd2e63b9afd3800b7776f6dc84a6e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> T , <a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> P , <a class="el" href="classloos_1_1_math_1_1_matrix.html">template</a>&lt; <a class="el" href="classloos_1_1_math_1_1_matrix.html">typename</a> &gt; <a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> S, <a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> F &gt; </td></tr>
<tr class="memitem:a09efd2e63b9afd3800b7776f6dc84a6e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a09efd2e63b9afd3800b7776f6dc84a6e">writeAsciiMatrix</a> (std::ostream &amp;os, const <a class="el" href="classloos_1_1_math_1_1_matrix.html">Math::Matrix</a>&lt; T, P, S &gt; &amp;M, const std::string &amp;meta, const <a class="el" href="namespaceloos_1_1_math.html#ad6e4e1580b47f3f204c4ff48a6658c24">Math::Range</a> &amp;start, const <a class="el" href="namespaceloos_1_1_math.html#ad6e4e1580b47f3f204c4ff48a6658c24">Math::Range</a> &amp;end, const bool trans=false, F fmt=F())</td></tr>
<tr class="memdesc:a09efd2e63b9afd3800b7776f6dc84a6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a submatrix to a stream.  <br /></td></tr>
<tr class="separator:a09efd2e63b9afd3800b7776f6dc84a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd11e95b47bf7992a802d7ce96e7b74f" id="r_abd11e95b47bf7992a802d7ce96e7b74f"><td class="memTemplParams" colspan="2"><a id="abd11e95b47bf7992a802d7ce96e7b74f" name="abd11e95b47bf7992a802d7ce96e7b74f"></a>
template&lt;<a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> T , <a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> P , <a class="el" href="classloos_1_1_math_1_1_matrix.html">template</a>&lt; <a class="el" href="classloos_1_1_math_1_1_matrix.html">typename</a> &gt; <a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> S&gt; </td></tr>
<tr class="memitem:abd11e95b47bf7992a802d7ce96e7b74f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>writeAsciiMatrix</b> (std::ostream &amp;os, const <a class="el" href="classloos_1_1_math_1_1_matrix.html">Math::Matrix</a>&lt; T, P, S &gt; &amp;M, const std::string &amp;meta, const <a class="el" href="namespaceloos_1_1_math.html#ad6e4e1580b47f3f204c4ff48a6658c24">Math::Range</a> &amp;start, const <a class="el" href="namespaceloos_1_1_math.html#ad6e4e1580b47f3f204c4ff48a6658c24">Math::Range</a> &amp;end, const bool trans=false)</td></tr>
<tr class="memdesc:abd11e95b47bf7992a802d7ce96e7b74f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a submatrix to a stream. <br /></td></tr>
<tr class="separator:abd11e95b47bf7992a802d7ce96e7b74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2ca00fd1ba6488e8f4066459601cd3" id="r_a0b2ca00fd1ba6488e8f4066459601cd3"><td class="memTemplParams" colspan="2"><a id="a0b2ca00fd1ba6488e8f4066459601cd3" name="a0b2ca00fd1ba6488e8f4066459601cd3"></a>
template&lt;<a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> T , <a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> P , <a class="el" href="classloos_1_1_math_1_1_matrix.html">template</a>&lt; <a class="el" href="classloos_1_1_math_1_1_matrix.html">typename</a> &gt; <a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> S, <a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> F &gt; </td></tr>
<tr class="memitem:a0b2ca00fd1ba6488e8f4066459601cd3"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>writeAsciiMatrix</b> (std::ostream &amp;os, const <a class="el" href="classloos_1_1_math_1_1_matrix.html">Math::Matrix</a>&lt; T, P, S &gt; &amp;M, const std::string &amp;meta, const bool trans=false, F fmt=F())</td></tr>
<tr class="memdesc:a0b2ca00fd1ba6488e8f4066459601cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an entire matrix to a stream. <br /></td></tr>
<tr class="separator:a0b2ca00fd1ba6488e8f4066459601cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c27dfb56522a23f2522dd6019e71217" id="r_a0c27dfb56522a23f2522dd6019e71217"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> T , <a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> P , <a class="el" href="classloos_1_1_math_1_1_matrix.html">template</a>&lt; <a class="el" href="classloos_1_1_math_1_1_matrix.html">typename</a> &gt; <a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> S&gt; </td></tr>
<tr class="memitem:a0c27dfb56522a23f2522dd6019e71217"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0c27dfb56522a23f2522dd6019e71217">writeAsciiMatrix</a> (std::ostream &amp;os, const <a class="el" href="classloos_1_1_math_1_1_matrix.html">Math::Matrix</a>&lt; T, P, S &gt; &amp;M, const std::string &amp;meta, const bool trans=false)</td></tr>
<tr class="memdesc:a0c27dfb56522a23f2522dd6019e71217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an entire matrix to a stream.  <br /></td></tr>
<tr class="separator:a0c27dfb56522a23f2522dd6019e71217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb2b19efa2dd29b200b34a93216c14b" id="r_aacb2b19efa2dd29b200b34a93216c14b"><td class="memTemplParams" colspan="2"><a id="aacb2b19efa2dd29b200b34a93216c14b" name="aacb2b19efa2dd29b200b34a93216c14b"></a>
template&lt;<a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> T , <a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> P , <a class="el" href="classloos_1_1_math_1_1_matrix.html">template</a>&lt; <a class="el" href="classloos_1_1_math_1_1_matrix.html">typename</a> &gt; <a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> S, <a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> F &gt; </td></tr>
<tr class="memitem:aacb2b19efa2dd29b200b34a93216c14b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>writeAsciiMatrix</b> (const std::string &amp;fname, const <a class="el" href="classloos_1_1_math_1_1_matrix.html">Math::Matrix</a>&lt; T, P, S &gt; &amp;M, const std::string &amp;meta, const <a class="el" href="namespaceloos_1_1_math.html#ad6e4e1580b47f3f204c4ff48a6658c24">Math::Range</a> &amp;start, const <a class="el" href="namespaceloos_1_1_math.html#ad6e4e1580b47f3f204c4ff48a6658c24">Math::Range</a> &amp;end, const bool trans=false, F fmt=F())</td></tr>
<tr class="memdesc:aacb2b19efa2dd29b200b34a93216c14b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a submatrix to a file. <br /></td></tr>
<tr class="separator:aacb2b19efa2dd29b200b34a93216c14b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d8f9638487d808a278351d80f813a2" id="r_ae9d8f9638487d808a278351d80f813a2"><td class="memTemplParams" colspan="2"><a id="ae9d8f9638487d808a278351d80f813a2" name="ae9d8f9638487d808a278351d80f813a2"></a>
template&lt;<a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> T , <a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> P , <a class="el" href="classloos_1_1_math_1_1_matrix.html">template</a>&lt; <a class="el" href="classloos_1_1_math_1_1_matrix.html">typename</a> &gt; <a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> S&gt; </td></tr>
<tr class="memitem:ae9d8f9638487d808a278351d80f813a2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>writeAsciiMatrix</b> (const std::string &amp;fname, const <a class="el" href="classloos_1_1_math_1_1_matrix.html">Math::Matrix</a>&lt; T, P, S &gt; &amp;M, const std::string &amp;meta, const <a class="el" href="namespaceloos_1_1_math.html#ad6e4e1580b47f3f204c4ff48a6658c24">Math::Range</a> &amp;start, const <a class="el" href="namespaceloos_1_1_math.html#ad6e4e1580b47f3f204c4ff48a6658c24">Math::Range</a> &amp;end, const bool trans=false)</td></tr>
<tr class="memdesc:ae9d8f9638487d808a278351d80f813a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a submatrix to a file. <br /></td></tr>
<tr class="separator:ae9d8f9638487d808a278351d80f813a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd2e70f929e714ccc204509826aa755" id="r_a3dd2e70f929e714ccc204509826aa755"><td class="memTemplParams" colspan="2"><a id="a3dd2e70f929e714ccc204509826aa755" name="a3dd2e70f929e714ccc204509826aa755"></a>
template&lt;<a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> T , <a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> P , <a class="el" href="classloos_1_1_math_1_1_matrix.html">template</a>&lt; <a class="el" href="classloos_1_1_math_1_1_matrix.html">typename</a> &gt; <a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> S, <a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> F &gt; </td></tr>
<tr class="memitem:a3dd2e70f929e714ccc204509826aa755"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>writeAsciiMatrix</b> (const std::string &amp;fname, const <a class="el" href="classloos_1_1_math_1_1_matrix.html">Math::Matrix</a>&lt; T, P, S &gt; &amp;M, const std::string &amp;meta, const bool trans=false, F fmt=F())</td></tr>
<tr class="memdesc:a3dd2e70f929e714ccc204509826aa755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an entire matrix to a file. <br /></td></tr>
<tr class="separator:a3dd2e70f929e714ccc204509826aa755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b71724c3ca8b3c7f53db1f5981d9252" id="r_a1b71724c3ca8b3c7f53db1f5981d9252"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> T , <a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> P , <a class="el" href="classloos_1_1_math_1_1_matrix.html">template</a>&lt; <a class="el" href="classloos_1_1_math_1_1_matrix.html">typename</a> &gt; <a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> S&gt; </td></tr>
<tr class="memitem:a1b71724c3ca8b3c7f53db1f5981d9252"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1b71724c3ca8b3c7f53db1f5981d9252">writeAsciiMatrix</a> (const std::string &amp;fname, const <a class="el" href="classloos_1_1_math_1_1_matrix.html">Math::Matrix</a>&lt; T, P, S &gt; &amp;M, const std::string &amp;meta, const bool trans=false)</td></tr>
<tr class="memdesc:a1b71724c3ca8b3c7f53db1f5981d9252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write an entire matrix to a file.  <br /></td></tr>
<tr class="separator:a1b71724c3ca8b3c7f53db1f5981d9252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9815f82f55b7f0c25752425586cbad2" id="r_ae9815f82f55b7f0c25752425586cbad2"><td class="memItemLeft" align="right" valign="top"><a id="ae9815f82f55b7f0c25752425586cbad2" name="ae9815f82f55b7f0c25752425586cbad2"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>FormattedUnitCell</b> (std::ostream &amp;os, const <a class="el" href="classloos_1_1_unit_cell.html">UnitCell</a> &amp;<a class="el" href="classloos_1_1_math_1_1_matrix.html">u</a>)</td></tr>
<tr class="separator:ae9815f82f55b7f0c25752425586cbad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd536924db2e76350f7cb84ec4c86c3f" id="r_acd536924db2e76350f7cb84ec4c86c3f"><td class="memItemLeft" align="right" valign="top"><a id="acd536924db2e76350f7cb84ec4c86c3f" name="acd536924db2e76350f7cb84ec4c86c3f"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>XTALLine</b> (std::ostream &amp;os, const <a class="el" href="classloos_1_1_coord.html">GCoord</a> &amp;box)</td></tr>
<tr class="separator:acd536924db2e76350f7cb84ec4c86c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bdb9db70169149973ef581c957b86d3" id="r_a8bdb9db70169149973ef581c957b86d3"><td class="memItemLeft" align="right" valign="top"><a id="a8bdb9db70169149973ef581c957b86d3" name="a8bdb9db70169149973ef581c957b86d3"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>FormatConectRecords</b> (std::ostream &amp;os, const <a class="el" href="classloos_1_1_p_d_b.html">PDB</a> &amp;p)</td></tr>
<tr class="separator:a8bdb9db70169149973ef581c957b86d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aa719d784c66d87513bd26d6928536b" id="r_a9aa719d784c66d87513bd26d6928536b"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9aa719d784c66d87513bd26d6928536b">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classloos_1_1_p_d_b.html">PDB</a> &amp;p)</td></tr>
<tr class="memdesc:a9aa719d784c66d87513bd26d6928536b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the group as a <a class="el" href="classloos_1_1_p_d_b.html" title="PDB reading/writing class.">PDB</a>...  <br /></td></tr>
<tr class="separator:a9aa719d784c66d87513bd26d6928536b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e1cfa18b26d42be0b4df386915b1abc" id="r_a0e1cfa18b26d42be0b4df386915b1abc"><td class="memItemLeft" align="right" valign="top"><a id="a0e1cfa18b26d42be0b4df386915b1abc" name="a0e1cfa18b26d42be0b4df386915b1abc"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classloos_1_1_remarks.html">Remarks</a> &amp;r)</td></tr>
<tr class="separator:a0e1cfa18b26d42be0b4df386915b1abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8aae67eea00e8b5a151880fa6ce2df4" id="r_ae8aae67eea00e8b5a151880fa6ce2df4"><td class="memItemLeft" align="right" valign="top"><a id="ae8aae67eea00e8b5a151880fa6ce2df4" name="ae8aae67eea00e8b5a151880fa6ce2df4"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>availableSystemFileTypes</b> (const std::string &amp;prefix)</td></tr>
<tr class="separator:ae8aae67eea00e8b5a151880fa6ce2df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab88442242c02d5fba2d8486cf733ca8a" id="r_ab88442242c02d5fba2d8486cf733ca8a"><td class="memItemLeft" align="right" valign="top"><a id="ab88442242c02d5fba2d8486cf733ca8a" name="ab88442242c02d5fba2d8486cf733ca8a"></a>
pAtomicGroup&#160;</td><td class="memItemRight" valign="bottom"><b>createSystemPtr</b> (const std::string &amp;filename, const std::string &amp;<a class="el" href="classloos_1_1_math_1_1_matrix.html">filetype</a>)</td></tr>
<tr class="separator:ab88442242c02d5fba2d8486cf733ca8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c3c6426f2a874bf1b5bbda549a45291" id="r_a7c3c6426f2a874bf1b5bbda549a45291"><td class="memItemLeft" align="right" valign="top"><a id="a7c3c6426f2a874bf1b5bbda549a45291" name="a7c3c6426f2a874bf1b5bbda549a45291"></a>
pAtomicGroup&#160;</td><td class="memItemRight" valign="bottom"><b>createSystemPtr</b> (const std::string &amp;filename)</td></tr>
<tr class="separator:a7c3c6426f2a874bf1b5bbda549a45291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb266964bdaa10942329c7747adce633" id="r_acb266964bdaa10942329c7747adce633"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb266964bdaa10942329c7747adce633">createSystem</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:acb266964bdaa10942329c7747adce633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory function for reading in structure files.  <br /></td></tr>
<tr class="separator:acb266964bdaa10942329c7747adce633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a780ea25bfcceb8473e0061e8347ec9a5" id="r_a780ea25bfcceb8473e0061e8347ec9a5"><td class="memItemLeft" align="right" valign="top"><a id="a780ea25bfcceb8473e0061e8347ec9a5" name="a780ea25bfcceb8473e0061e8347ec9a5"></a>
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><b>createSystem</b> (const std::string &amp;filename, const std::string &amp;<a class="el" href="classloos_1_1_math_1_1_matrix.html">filetype</a>)</td></tr>
<tr class="separator:a780ea25bfcceb8473e0061e8347ec9a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91abab23d6d7f189b8213077538f4b3b" id="r_a91abab23d6d7f189b8213077538f4b3b"><td class="memItemLeft" align="right" valign="top"><a id="a91abab23d6d7f189b8213077538f4b3b" name="a91abab23d6d7f189b8213077538f4b3b"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>availableTrajectoryFileTypes</b> (const std::string &amp;prefix)</td></tr>
<tr class="separator:a91abab23d6d7f189b8213077538f4b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679943e849946c7782c1b0716941d390" id="r_a679943e849946c7782c1b0716941d390"><td class="memItemLeft" align="right" valign="top"><a id="a679943e849946c7782c1b0716941d390" name="a679943e849946c7782c1b0716941d390"></a>
pTraj&#160;</td><td class="memItemRight" valign="bottom"><b>createTrajectory</b> (const std::string &amp;filename, const std::string &amp;<a class="el" href="classloos_1_1_math_1_1_matrix.html">filetype</a>, const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;g)</td></tr>
<tr class="separator:a679943e849946c7782c1b0716941d390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c3b7c1613a234d4b4d23f23b5d4af6f" id="r_a5c3b7c1613a234d4b4d23f23b5d4af6f"><td class="memItemLeft" align="right" valign="top">pTraj&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c3b7c1613a234d4b4d23f23b5d4af6f">createTrajectory</a> (const std::string &amp;, const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;)</td></tr>
<tr class="memdesc:a5c3b7c1613a234d4b4d23f23b5d4af6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory function for reading in a trajectory file.  <br /></td></tr>
<tr class="separator:a5c3b7c1613a234d4b4d23f23b5d4af6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81981b62c6359fcc7efb602a4052b95f" id="r_a81981b62c6359fcc7efb602a4052b95f"><td class="memItemLeft" align="right" valign="top"><a id="a81981b62c6359fcc7efb602a4052b95f" name="a81981b62c6359fcc7efb602a4052b95f"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>availableOutputTrajectoryFileTypes</b> (const std::string &amp;prefix)</td></tr>
<tr class="separator:a81981b62c6359fcc7efb602a4052b95f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a345eb4ec3d6cdf14ce032c86e8875d53" id="r_a345eb4ec3d6cdf14ce032c86e8875d53"><td class="memItemLeft" align="right" valign="top"><a id="a345eb4ec3d6cdf14ce032c86e8875d53" name="a345eb4ec3d6cdf14ce032c86e8875d53"></a>
pTrajectoryWriter&#160;</td><td class="memItemRight" valign="bottom"><b>createOutputTrajectory</b> (const std::string &amp;filename, const std::string &amp;type, const bool append)</td></tr>
<tr class="separator:a345eb4ec3d6cdf14ce032c86e8875d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d683eed7d375c78108025222edae89" id="r_a48d683eed7d375c78108025222edae89"><td class="memItemLeft" align="right" valign="top"><a id="a48d683eed7d375c78108025222edae89" name="a48d683eed7d375c78108025222edae89"></a>
pTrajectoryWriter&#160;</td><td class="memItemRight" valign="bottom"><b>createOutputTrajectory</b> (const std::string &amp;filename, const bool append)</td></tr>
<tr class="separator:a48d683eed7d375c78108025222edae89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcbceccb5ba3893220304b71353a9f59" id="r_afcbceccb5ba3893220304b71353a9f59"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classloos_1_1_math_1_1_matrix.html">typename</a> T , <a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> SortPredicate &gt; </td></tr>
<tr class="memitem:afcbceccb5ba3893220304b71353a9f59"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; uint &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afcbceccb5ba3893220304b71353a9f59">sortedIndex</a> (const T &amp;A)</td></tr>
<tr class="separator:afcbceccb5ba3893220304b71353a9f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a460473438a3eaaf32cdcf283c8eac332" id="r_a460473438a3eaaf32cdcf283c8eac332"><td class="memTemplParams" colspan="2"><a id="a460473438a3eaaf32cdcf283c8eac332" name="a460473438a3eaaf32cdcf283c8eac332"></a>
template&lt;<a class="el" href="classloos_1_1_math_1_1_matrix.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a460473438a3eaaf32cdcf283c8eac332"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; uint &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sortedIndex</b> (const T &amp;A)</td></tr>
<tr class="memdesc:a460473438a3eaaf32cdcf283c8eac332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a container in ascending sequence. <br /></td></tr>
<tr class="separator:a460473438a3eaaf32cdcf283c8eac332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a363b240e30a710c8f48ad1bc7c08d5a8" id="r_a363b240e30a710c8f48ad1bc7c08d5a8"><td class="memItemLeft" align="right" valign="top"><a id="a363b240e30a710c8f48ad1bc7c08d5a8" name="a363b240e30a710c8f48ad1bc7c08d5a8"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>findBaseName</b> (const std::string &amp;)</td></tr>
<tr class="memdesc:a363b240e30a710c8f48ad1bc7c08d5a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pull off the file name extension (if present) <br /></td></tr>
<tr class="separator:a363b240e30a710c8f48ad1bc7c08d5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade8ebb4bc959bbfeccc0a42324808db8" id="r_ade8ebb4bc959bbfeccc0a42324808db8"><td class="memItemLeft" align="right" valign="top"><a id="ade8ebb4bc959bbfeccc0a42324808db8" name="ade8ebb4bc959bbfeccc0a42324808db8"></a>
boost::tuple&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>splitFilename</b> (const std::string &amp;filename)</td></tr>
<tr class="separator:ade8ebb4bc959bbfeccc0a42324808db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54dd62fa117e274ec179938359eda8ba" id="r_a54dd62fa117e274ec179938359eda8ba"><td class="memItemLeft" align="right" valign="top"><a id="a54dd62fa117e274ec179938359eda8ba" name="a54dd62fa117e274ec179938359eda8ba"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getNextLine</b> (std::istream &amp;is, int *lineno)</td></tr>
<tr class="memdesc:a54dd62fa117e274ec179938359eda8ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next line of input, skipping blanks and stripping comments. <br /></td></tr>
<tr class="separator:a54dd62fa117e274ec179938359eda8ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9938bb182cff8aeddeb0eb7aac81b09f" id="r_a9938bb182cff8aeddeb0eb7aac81b09f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9938bb182cff8aeddeb0eb7aac81b09f">invocationHeader</a> (int, char *[])</td></tr>
<tr class="memdesc:a9938bb182cff8aeddeb0eb7aac81b09f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an invocation header.  <br /></td></tr>
<tr class="separator:a9938bb182cff8aeddeb0eb7aac81b09f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750b5d795f43978407dc4e9127c7db03" id="r_a750b5d795f43978407dc4e9127c7db03"><td class="memItemLeft" align="right" valign="top"><a id="a750b5d795f43978407dc4e9127c7db03" name="a750b5d795f43978407dc4e9127c7db03"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>parseRangeList</b> (const std::string &amp;, const int endpoint=0)</td></tr>
<tr class="memdesc:a750b5d795f43978407dc4e9127c7db03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a list of Octave-style range specifiers (for compatability) <br /></td></tr>
<tr class="separator:a750b5d795f43978407dc4e9127c7db03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ad12706a6b9884cc8f3a5677a899e3" id="r_a01ad12706a6b9884cc8f3a5677a899e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01ad12706a6b9884cc8f3a5677a899e3">selectAtoms</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;, const std::string)</td></tr>
<tr class="memdesc:a01ad12706a6b9884cc8f3a5677a899e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a string-based selection to an atomic group...  <br /></td></tr>
<tr class="separator:a01ad12706a6b9884cc8f3a5677a899e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa080c6848021738d86d5dc4a73c19bd" id="r_aaa080c6848021738d86d5dc4a73c19bd"><td class="memItemLeft" align="right" valign="top"><a id="aaa080c6848021738d86d5dc4a73c19bd" name="aaa080c6848021738d86d5dc4a73c19bd"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>timeAsString</b> (const double t, const uint precision=0)</td></tr>
<tr class="memdesc:aaa080c6848021738d86d5dc4a73c19bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert t (seconds) into a string, converting to hours and minutes as necessary. <br /></td></tr>
<tr class="separator:aaa080c6848021738d86d5dc4a73c19bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49dc2fc2f2753b7714a41fbedb227189" id="r_a49dc2fc2f2753b7714a41fbedb227189"><td class="memItemLeft" align="right" valign="top"><a id="a49dc2fc2f2753b7714a41fbedb227189" name="a49dc2fc2f2753b7714a41fbedb227189"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a49dc2fc2f2753b7714a41fbedb227189"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parseStringAs&lt; std::string &gt;</b> (const std::string &amp;source, const uint pos, const uint nelem)</td></tr>
<tr class="separator:a49dc2fc2f2753b7714a41fbedb227189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc6015c531612f5cc23706fde42b78fa" id="r_adc6015c531612f5cc23706fde42b78fa"><td class="memItemLeft" align="right" valign="top"><a id="adc6015c531612f5cc23706fde42b78fa" name="adc6015c531612f5cc23706fde42b78fa"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:adc6015c531612f5cc23706fde42b78fa"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fixedSizeFormat</b> (const std::string &amp;s, const uint n)</td></tr>
<tr class="separator:adc6015c531612f5cc23706fde42b78fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79bc7f779a522f273b9437a8280b60ee" id="r_a79bc7f779a522f273b9437a8280b60ee"><td class="memItemLeft" align="right" valign="top"><a id="a79bc7f779a522f273b9437a8280b60ee" name="a79bc7f779a522f273b9437a8280b60ee"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>parseStringAsHybrid36</b> (const std::string &amp;source, const uint pos=0, const uint nelem=0)</td></tr>
<tr class="memdesc:a79bc7f779a522f273b9437a8280b60ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a hybrid-36 encoded string into an int. <br /></td></tr>
<tr class="separator:a79bc7f779a522f273b9437a8280b60ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab01118ab9b5036271c399aedee6eccbb" id="r_ab01118ab9b5036271c399aedee6eccbb"><td class="memItemLeft" align="right" valign="top"><a id="ab01118ab9b5036271c399aedee6eccbb" name="ab01118ab9b5036271c399aedee6eccbb"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>hybrid36AsString</b> (int value, uint <a class="el" href="classloos_1_1_math_1_1_matrix.html">fieldsize</a>)</td></tr>
<tr class="memdesc:ab01118ab9b5036271c399aedee6eccbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an int into a hybrid-36 encoded string. <br /></td></tr>
<tr class="separator:ab01118ab9b5036271c399aedee6eccbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91bd1f2095f292abfd3b70f9415a9d57" id="r_a91bd1f2095f292abfd3b70f9415a9d57"><td class="memItemLeft" align="right" valign="top"><a id="a91bd1f2095f292abfd3b70f9415a9d57" name="a91bd1f2095f292abfd3b70f9415a9d57"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>sanitizeString</b> (const std::string &amp;s)</td></tr>
<tr class="memdesc:a91bd1f2095f292abfd3b70f9415a9d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes internal newlines from string. <br /></td></tr>
<tr class="separator:a91bd1f2095f292abfd3b70f9415a9d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db0c1b0db1fa0f298f82402e4a70219" id="r_a7db0c1b0db1fa0f298f82402e4a70219"><td class="memItemLeft" align="right" valign="top"><a id="a7db0c1b0db1fa0f298f82402e4a70219" name="a7db0c1b0db1fa0f298f82402e4a70219"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>stringsAsComments</b> (const std::vector&lt; std::string &gt; &amp;v)</td></tr>
<tr class="memdesc:a7db0c1b0db1fa0f298f82402e4a70219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a vector of strings into a standard log format. <br /></td></tr>
<tr class="separator:a7db0c1b0db1fa0f298f82402e4a70219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48bae3110e11bb30502050796b4cd586" id="r_a48bae3110e11bb30502050796b4cd586"><td class="memItemLeft" align="right" valign="top"><a id="a48bae3110e11bb30502050796b4cd586" name="a48bae3110e11bb30502050796b4cd586"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>stringsAsString</b> (const std::vector&lt; std::string &gt; &amp;v)</td></tr>
<tr class="memdesc:a48bae3110e11bb30502050796b4cd586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a vector of strings into a single string with newlines. <br /></td></tr>
<tr class="separator:a48bae3110e11bb30502050796b4cd586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8783c2b04ba43093b26f20f769d5afae" id="r_a8783c2b04ba43093b26f20f769d5afae"><td class="memItemLeft" align="right" valign="top"><a id="a8783c2b04ba43093b26f20f769d5afae" name="a8783c2b04ba43093b26f20f769d5afae"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a8783c2b04ba43093b26f20f769d5afae"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vectorAsStringWithCommas</b> (const std::vector&lt; std::string &gt; &amp;v)</td></tr>
<tr class="memdesc:a8783c2b04ba43093b26f20f769d5afae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for strings that sanitizes the contained strings. <br /></td></tr>
<tr class="separator:a8783c2b04ba43093b26f20f769d5afae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34d379cd19a139ee185b55d1e96c724" id="r_ad34d379cd19a139ee185b55d1e96c724"><td class="memItemLeft" align="right" valign="top"><a id="ad34d379cd19a139ee185b55d1e96c724" name="ad34d379cd19a139ee185b55d1e96c724"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><b>availableMemory</b> ()</td></tr>
<tr class="separator:ad34d379cd19a139ee185b55d1e96c724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37368a8e72cbbefae7053afdc0756c25" id="r_a37368a8e72cbbefae7053afdc0756c25"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classloos_1_1_math_1_1_matrix.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a37368a8e72cbbefae7053afdc0756c25"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a37368a8e72cbbefae7053afdc0756c25">readVector</a> (<a class="el" href="classloos_1_1_line_reader.html">LineReader</a> &amp;reader)</td></tr>
<tr class="memdesc:a37368a8e72cbbefae7053afdc0756c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a list of items using a <a class="el" href="classloos_1_1_line_reader.html" title="Class for reading line-by-line from a file while tracking line numbers and stripping comments.">LineReader</a> object.  <br /></td></tr>
<tr class="separator:a37368a8e72cbbefae7053afdc0756c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1e11b0352b618afe84affdf8126e702" id="r_ab1e11b0352b618afe84affdf8126e702"><td class="memTemplParams" colspan="2"><a id="ab1e11b0352b618afe84affdf8126e702" name="ab1e11b0352b618afe84affdf8126e702"></a>
template&lt;<a class="el" href="classloos_1_1_math_1_1_matrix.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ab1e11b0352b618afe84affdf8126e702"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>readVector</b> (std::istream &amp;is)</td></tr>
<tr class="memdesc:ab1e11b0352b618afe84affdf8126e702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a list of items from a stream with default behavior. <br /></td></tr>
<tr class="separator:ab1e11b0352b618afe84affdf8126e702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ac90eab76232c7880c220391a57f09" id="r_a81ac90eab76232c7880c220391a57f09"><td class="memTemplParams" colspan="2"><a id="a81ac90eab76232c7880c220391a57f09" name="a81ac90eab76232c7880c220391a57f09"></a>
template&lt;<a class="el" href="classloos_1_1_math_1_1_matrix.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a81ac90eab76232c7880c220391a57f09"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>readVector</b> (const std::string &amp;fname)</td></tr>
<tr class="memdesc:a81ac90eab76232c7880c220391a57f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a list of items from a file with default behavior. <br /></td></tr>
<tr class="separator:a81ac90eab76232c7880c220391a57f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946b258c3b8510b1f042fb09088b992c" id="r_a946b258c3b8510b1f042fb09088b992c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classloos_1_1_math_1_1_matrix.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a946b258c3b8510b1f042fb09088b992c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a946b258c3b8510b1f042fb09088b992c">readTable</a> (<a class="el" href="classloos_1_1_line_reader.html">LineReader</a> &amp;reader)</td></tr>
<tr class="memdesc:a946b258c3b8510b1f042fb09088b992c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read in a table of items using a <a class="el" href="classloos_1_1_line_reader.html" title="Class for reading line-by-line from a file while tracking line numbers and stripping comments.">LineReader</a> object.  <br /></td></tr>
<tr class="separator:a946b258c3b8510b1f042fb09088b992c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23aeb4bdefe75a192edee06161e557c8" id="r_a23aeb4bdefe75a192edee06161e557c8"><td class="memTemplParams" colspan="2"><a id="a23aeb4bdefe75a192edee06161e557c8" name="a23aeb4bdefe75a192edee06161e557c8"></a>
template&lt;<a class="el" href="classloos_1_1_math_1_1_matrix.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a23aeb4bdefe75a192edee06161e557c8"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>readTable</b> (std::istream &amp;is)</td></tr>
<tr class="memdesc:a23aeb4bdefe75a192edee06161e557c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read in a table given a stream. <br /></td></tr>
<tr class="separator:a23aeb4bdefe75a192edee06161e557c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a948fb2d3040ea73b31c9d386b8a60f4a" id="r_a948fb2d3040ea73b31c9d386b8a60f4a"><td class="memTemplParams" colspan="2"><a id="a948fb2d3040ea73b31c9d386b8a60f4a" name="a948fb2d3040ea73b31c9d386b8a60f4a"></a>
template&lt;<a class="el" href="classloos_1_1_math_1_1_matrix.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a948fb2d3040ea73b31c9d386b8a60f4a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>readTable</b> (const std::string &amp;fname)</td></tr>
<tr class="memdesc:a948fb2d3040ea73b31c9d386b8a60f4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read in a table given a filename. <br /></td></tr>
<tr class="separator:a948fb2d3040ea73b31c9d386b8a60f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ab4282e526a1e5cb89a7d0c2f4ef45" id="r_a94ab4282e526a1e5cb89a7d0c2f4ef45"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classloos_1_1_math_1_1_matrix.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a94ab4282e526a1e5cb89a7d0c2f4ef45"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a94ab4282e526a1e5cb89a7d0c2f4ef45">parseRange</a> (const std::string &amp;text, const T endpoint=0)</td></tr>
<tr class="memdesc:a94ab4282e526a1e5cb89a7d0c2f4ef45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an Octave/Matlab-style range.  <br /></td></tr>
<tr class="separator:a94ab4282e526a1e5cb89a7d0c2f4ef45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23448ed73a24493021dd00473c70deed" id="r_a23448ed73a24493021dd00473c70deed"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classloos_1_1_math_1_1_matrix.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a23448ed73a24493021dd00473c70deed"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a23448ed73a24493021dd00473c70deed">parseRangeList</a> (const std::string &amp;text, const T endpoint=0)</td></tr>
<tr class="memdesc:a23448ed73a24493021dd00473c70deed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a comma-separated list of Octave-style ranges.  <br /></td></tr>
<tr class="separator:a23448ed73a24493021dd00473c70deed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee1d37c2e56e0ad918e9e4fb783a5416" id="r_aee1d37c2e56e0ad918e9e4fb783a5416"><td class="memTemplParams" colspan="2"><a id="aee1d37c2e56e0ad918e9e4fb783a5416" name="aee1d37c2e56e0ad918e9e4fb783a5416"></a>
template&lt;<a class="el" href="classloos_1_1_math_1_1_matrix.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aee1d37c2e56e0ad918e9e4fb783a5416"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parseRangeList</b> (const std::vector&lt; std::string &gt; &amp;ranges, const T endpoint=0)</td></tr>
<tr class="memdesc:aee1d37c2e56e0ad918e9e4fb783a5416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a list of Octave-style ranges taken from a vector of strings. <br /></td></tr>
<tr class="separator:aee1d37c2e56e0ad918e9e4fb783a5416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee1021d75b06b63e2410636b11179c1a" id="r_aee1021d75b06b63e2410636b11179c1a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classloos_1_1_math_1_1_matrix.html">typename</a> T &gt; </td></tr>
<tr class="memitem:aee1021d75b06b63e2410636b11179c1a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aee1021d75b06b63e2410636b11179c1a">swab</a> (const T &amp;datum)</td></tr>
<tr class="memdesc:aee1021d75b06b63e2410636b11179c1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a byte-swapped copy of an arbitrary type.  <br /></td></tr>
<tr class="separator:aee1021d75b06b63e2410636b11179c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8810a947ea516380336323ac9f98dc07" id="r_a8810a947ea516380336323ac9f98dc07"><td class="memTemplParams" colspan="2"><a id="a8810a947ea516380336323ac9f98dc07" name="a8810a947ea516380336323ac9f98dc07"></a>
template&lt;<a class="el" href="classloos_1_1_math_1_1_matrix.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a8810a947ea516380336323ac9f98dc07"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parseStringAs</b> (const std::string &amp;source, const uint pos=0, const uint nelem=0)</td></tr>
<tr class="memdesc:a8810a947ea516380336323ac9f98dc07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a field from a string. <br /></td></tr>
<tr class="separator:a8810a947ea516380336323ac9f98dc07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49dc2fc2f2753b7714a41fbedb227189" id="r_a49dc2fc2f2753b7714a41fbedb227189"><td class="memItemLeft" align="right" valign="top"><a id="a49dc2fc2f2753b7714a41fbedb227189" name="a49dc2fc2f2753b7714a41fbedb227189"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a49dc2fc2f2753b7714a41fbedb227189"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parseStringAs&lt; std::string &gt;</b> (const std::string &amp;source, const uint pos, const uint nelem)</td></tr>
<tr class="separator:a49dc2fc2f2753b7714a41fbedb227189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea93b358c7f352d1d565cc76651452a" id="r_abea93b358c7f352d1d565cc76651452a"><td class="memTemplParams" colspan="2"><a id="abea93b358c7f352d1d565cc76651452a" name="abea93b358c7f352d1d565cc76651452a"></a>
template&lt;<a class="el" href="classloos_1_1_math_1_1_matrix.html">typename</a> T &gt; </td></tr>
<tr class="memitem:abea93b358c7f352d1d565cc76651452a"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fixedSizeFormat</b> (const T t, const uint n)</td></tr>
<tr class="separator:abea93b358c7f352d1d565cc76651452a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc6015c531612f5cc23706fde42b78fa" id="r_adc6015c531612f5cc23706fde42b78fa"><td class="memItemLeft" align="right" valign="top"><a id="adc6015c531612f5cc23706fde42b78fa" name="adc6015c531612f5cc23706fde42b78fa"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:adc6015c531612f5cc23706fde42b78fa"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fixedSizeFormat</b> (const std::string &amp;s, const uint n)</td></tr>
<tr class="separator:adc6015c531612f5cc23706fde42b78fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae63f81614006afb36b456a3e8d69cd02" id="r_ae63f81614006afb36b456a3e8d69cd02"><td class="memTemplParams" colspan="2"><a id="ae63f81614006afb36b456a3e8d69cd02" name="ae63f81614006afb36b456a3e8d69cd02"></a>
template&lt;<a class="el" href="classloos_1_1_math_1_1_matrix.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ae63f81614006afb36b456a3e8d69cd02"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vToString</b> (const T &amp;x)</td></tr>
<tr class="memdesc:ae63f81614006afb36b456a3e8d69cd02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert something that can iterate into a string... <br /></td></tr>
<tr class="separator:ae63f81614006afb36b456a3e8d69cd02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac337138d3dd868ff6c78ff7606024425" id="r_ac337138d3dd868ff6c78ff7606024425"><td class="memTemplParams" colspan="2"><a id="ac337138d3dd868ff6c78ff7606024425" name="ac337138d3dd868ff6c78ff7606024425"></a>
template&lt;<a class="el" href="classloos_1_1_math_1_1_matrix.html">typename</a> T &gt; </td></tr>
<tr class="memitem:ac337138d3dd868ff6c78ff7606024425"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vectorAsStringWithCommas</b> (const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:ac337138d3dd868ff6c78ff7606024425"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a vector of type T to a string-list with commas. <br /></td></tr>
<tr class="separator:ac337138d3dd868ff6c78ff7606024425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8783c2b04ba43093b26f20f769d5afae" id="r_a8783c2b04ba43093b26f20f769d5afae"><td class="memItemLeft" align="right" valign="top"><a id="a8783c2b04ba43093b26f20f769d5afae" name="a8783c2b04ba43093b26f20f769d5afae"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a8783c2b04ba43093b26f20f769d5afae"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vectorAsStringWithCommas</b> (const std::vector&lt; std::string &gt; &amp;v)</td></tr>
<tr class="memdesc:a8783c2b04ba43093b26f20f769d5afae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for strings that sanitizes the contained strings. <br /></td></tr>
<tr class="separator:a8783c2b04ba43093b26f20f769d5afae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55988632364280c7861ce27b58cd169d" id="r_a55988632364280c7861ce27b58cd169d"><td class="memTemplParams" colspan="2"><a id="a55988632364280c7861ce27b58cd169d" name="a55988632364280c7861ce27b58cd169d"></a>
template&lt;<a class="el" href="classloos_1_1_math_1_1_matrix.html">typename</a> T &gt; </td></tr>
<tr class="memitem:a55988632364280c7861ce27b58cd169d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>uniquifyVector</b> (const std::vector&lt; T &gt; &amp;list)</td></tr>
<tr class="memdesc:a55988632364280c7861ce27b58cd169d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing only the unique elements of the input vector. <br /></td></tr>
<tr class="separator:a55988632364280c7861ce27b58cd169d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82436be3d1bfa01542d6a8f3820a38b" id="r_ab82436be3d1bfa01542d6a8f3820a38b"><td class="memItemLeft" align="right" valign="top">base_generator_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab82436be3d1bfa01542d6a8f3820a38b">rng_singleton</a> (void)</td></tr>
<tr class="memdesc:ab82436be3d1bfa01542d6a8f3820a38b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suite-wide random number generator singleton.  <br /></td></tr>
<tr class="separator:ab82436be3d1bfa01542d6a8f3820a38b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ade6e7564c4aa077a6f3134c6252663" id="r_a6ade6e7564c4aa077a6f3134c6252663"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ade6e7564c4aa077a6f3134c6252663">randomSeedRNG</a> (void)</td></tr>
<tr class="memdesc:a6ade6e7564c4aa077a6f3134c6252663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Randomly seeds the RNG.  <br /></td></tr>
<tr class="separator:a6ade6e7564c4aa077a6f3134c6252663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa994f20daba9b26f90c194c2c472382" id="r_aaa994f20daba9b26f90c194c2c472382"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classloos_1_1_coord.html">GCoord</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa994f20daba9b26f90c194c2c472382">boxFromRemarks</a> (const <a class="el" href="classloos_1_1_remarks.html">Remarks</a> &amp;)</td></tr>
<tr class="memdesc:aaa994f20daba9b26f90c194c2c472382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the Alan-style box-size from a <a class="el" href="classloos_1_1_p_d_b.html" title="PDB reading/writing class.">PDB</a> <a class="el" href="classloos_1_1_remarks.html" title="Class for handling PDB Remarks.">Remarks</a> block.  <br /></td></tr>
<tr class="separator:aaa994f20daba9b26f90c194c2c472382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99d766080fbbeea698c4c68594f9341" id="r_aa99d766080fbbeea698c4c68594f9341"><td class="memItemLeft" align="right" valign="top"><a id="aa99d766080fbbeea698c4c68594f9341" name="aa99d766080fbbeea698c4c68594f9341"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>remarksHasBox</b> (const <a class="el" href="classloos_1_1_remarks.html">Remarks</a> &amp;)</td></tr>
<tr class="memdesc:aa99d766080fbbeea698c4c68594f9341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="classloos_1_1_remarks.html" title="Class for handling PDB Remarks.">Remarks</a> block has an Alan-style box size in it. <br /></td></tr>
<tr class="separator:aa99d766080fbbeea698c4c68594f9341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b873907a2cd5784dbfd14b20c0f2edb" id="r_a8b873907a2cd5784dbfd14b20c0f2edb"><td class="memItemLeft" align="right" valign="top"><a id="a8b873907a2cd5784dbfd14b20c0f2edb" name="a8b873907a2cd5784dbfd14b20c0f2edb"></a>
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><b>loadStructureWithCoords</b> (const std::string &amp;model, const std::string &amp;<a class="el" href="classloos_1_1_math_1_1_matrix.html">cooords</a>)</td></tr>
<tr class="memdesc:a8b873907a2cd5784dbfd14b20c0f2edb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a structure and optional coordinates. <br /></td></tr>
<tr class="separator:a8b873907a2cd5784dbfd14b20c0f2edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a4390bc78763697346c0164da56ad7" id="r_af3a4390bc78763697346c0164da56ad7"><td class="memItemLeft" align="right" valign="top"><a id="af3a4390bc78763697346c0164da56ad7" name="af3a4390bc78763697346c0164da56ad7"></a>
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><b>loadStructureWithCoords</b> (const std::string &amp;model_name, const std::string &amp;type, const std::string &amp;<a class="el" href="classloos_1_1_math_1_1_matrix.html">coord_name</a>)</td></tr>
<tr class="separator:af3a4390bc78763697346c0164da56ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ca80dcc44112f32a37ffe8cb879fff" id="r_a58ca80dcc44112f32a37ffe8cb879fff"><td class="memItemLeft" align="right" valign="top"><a id="a58ca80dcc44112f32a37ffe8cb879fff" name="a58ca80dcc44112f32a37ffe8cb879fff"></a>
std::vector&lt; uint &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>assignTrajectoryFrames</b> (const pTraj &amp;traj, const std::string &amp;frame_index_spec, uint skip=0, uint stride=1)</td></tr>
<tr class="memdesc:a58ca80dcc44112f32a37ffe8cb879fff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a list of trajectory indices (frame_index_spec supercedes skip) <br /></td></tr>
<tr class="separator:a58ca80dcc44112f32a37ffe8cb879fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a0dae35230d98e7f256581097b046f214" id="r_a0dae35230d98e7f256581097b046f214"><td class="memItemLeft" align="right" valign="top"><a id="a0dae35230d98e7f256581097b046f214" name="a0dae35230d98e7f256581097b046f214"></a>
const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>version_string</b> = &quot;LOOS 4.1.0 <a class="el" href="classloos_1_1_math_1_1_matrix.html">BUILT</a> <a class="el" href="classloos_1_1_math_1_1_matrix.html">ON</a> 20240212 16:31:52&quot;</td></tr>
<tr class="separator:a0dae35230d98e7f256581097b046f214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d31eb9566329001c9c066ca28284118" id="r_a9d31eb9566329001c9c066ca28284118"><td class="memItemLeft" align="right" valign="top"><a id="a9d31eb9566329001c9c066ca28284118" name="a9d31eb9566329001c9c066ca28284118"></a>
const uint&#160;</td><td class="memItemRight" valign="bottom"><b>kilobytes</b> = 1024</td></tr>
<tr class="separator:a9d31eb9566329001c9c066ca28284118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8a839bdd5f8677e9f2fb3fbec971a2" id="r_aff8a839bdd5f8677e9f2fb3fbec971a2"><td class="memItemLeft" align="right" valign="top"><a id="aff8a839bdd5f8677e9f2fb3fbec971a2" name="aff8a839bdd5f8677e9f2fb3fbec971a2"></a>
const uint&#160;</td><td class="memItemRight" valign="bottom"><b>megabytes</b> = 1024 * kilobytes</td></tr>
<tr class="separator:aff8a839bdd5f8677e9f2fb3fbec971a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55aed2289adecf6edc63323e466bb7e5" id="r_a55aed2289adecf6edc63323e466bb7e5"><td class="memItemLeft" align="right" valign="top"><a id="a55aed2289adecf6edc63323e466bb7e5" name="a55aed2289adecf6edc63323e466bb7e5"></a>
const uint&#160;</td><td class="memItemRight" valign="bottom"><b>gigabytes</b> = 1024 * megabytes</td></tr>
<tr class="separator:a55aed2289adecf6edc63323e466bb7e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace for most things not already encapsulated within a class. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a50aefac013fa449999f74fa4e0df8b55" name="a50aefac013fa449999f74fa4e0df8b55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50aefac013fa449999f74fa4e0df8b55">&#9670;&#160;</a></span>averageStructure() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> loos::averageStructure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classloos_1_1_x_form.html">XForm</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pTraj &amp;</td>          <td class="paramname"><span class="paramname"><em>traj</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the average structure using all frames in a trajectory. </p>
<p>This version only reads a frame at a time from the trajectory. The trajectory iterator will be left pointing to the end of the trajectory. </p>

</div>
</div>
<a id="a145b1950c29d680031aaba768f133ce0" name="a145b1950c29d680031aaba768f133ce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a145b1950c29d680031aaba768f133ce0">&#9670;&#160;</a></span>averageStructure() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> loos::averageStructure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classloos_1_1_x_form.html">XForm</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pTraj &amp;</td>          <td class="paramname"><span class="paramname"><em>traj</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>indices</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the average structure from a trajectory reading only certain frames. </p>
<p>Note that the trajectory is NOT stored in memory. Frames will be read as needed. The trajectory "iterator" will be left pointing to the next frame after the last frame index passed. </p>

</div>
</div>
<a id="aa10ec538bd0a45ef4543c60489fb6a74" name="aa10ec538bd0a45ef4543c60489fb6a74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa10ec538bd0a45ef4543c60489fb6a74">&#9670;&#160;</a></span>averageStructure() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> loos::averageStructure </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ensemble</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classloos_1_1_x_form.html">XForm</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>xforms</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the average structure of a set of <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually)">AtomicGroup</a> objects. </p>
<p>Takes into consideration the passed set of transforms... </p>

</div>
</div>
<a id="aaa994f20daba9b26f90c194c2c472382" name="aaa994f20daba9b26f90c194c2c472382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa994f20daba9b26f90c194c2c472382">&#9670;&#160;</a></span>boxFromRemarks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_coord.html">GCoord</a> loos::boxFromRemarks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_remarks.html">Remarks</a> &amp;</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the Alan-style box-size from a <a class="el" href="classloos_1_1_p_d_b.html" title="PDB reading/writing class.">PDB</a> <a class="el" href="classloos_1_1_remarks.html" title="Class for handling PDB Remarks.">Remarks</a> block. </p>
<p>Returns a GCoord(<a class="el" href="classloos_1_1_math_1_1_matrix.html#a41fd964667734df58317f06f951dd513" title="Unitialized matrix.">99999.99</a>, <a class="el" href="classloos_1_1_math_1_1_matrix.html#a41fd964667734df58317f06f951dd513" title="Unitialized matrix.">99999.99</a>, <a class="el" href="classloos_1_1_math_1_1_matrix.html#a41fd964667734df58317f06f951dd513" title="Unitialized matrix.">99999.99</a>) if there is no box info found in the remarks block. </p>

</div>
</div>
<a id="acb266964bdaa10942329c7747adce633" name="acb266964bdaa10942329c7747adce633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb266964bdaa10942329c7747adce633">&#9670;&#160;</a></span>createSystem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> loos::createSystem </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>filename</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory function for reading in structure files. </p>
<p>This function will try to determine the filetype for a structure file by examining the suffix of the file. It will return an <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually)">AtomicGroup</a> copy of the input structure.</p>
<p><a class="el" href="classloos_1_1_amber.html" title="Class for reading in AMBER parmtop/coord files...">Amber</a> files are handled differently... If the filename ends with ".prmtop", then LOOS will check for a corresponding ".inpcrd" file. If one is found, then the coords will be loaded into the group. Otherwise, the prmtop will be loaded without coords and returned. </p>

</div>
</div>
<a id="a5c3b7c1613a234d4b4d23f23b5d4af6f" name="a5c3b7c1613a234d4b4d23f23b5d4af6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c3b7c1613a234d4b4d23f23b5d4af6f">&#9670;&#160;</a></span>createTrajectory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pTraj loos::createTrajectory </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory function for reading in a trajectory file. </p>
<p>This function will try to determine the filetype for a trajectory by examining the suffix of the file. It will return a boost shared pointer to a new <a class="el" href="classloos_1_1_trajectory.html" title="Base-class for polymorphic trajectories.">Trajectory</a> object.</p>
<p>It is <em>very</em> <em>important</em> to understand that the object returned by this function must behave polymorphically. That's why it is wrapped in a boost shared pointer to the base class. Do not try to deference it and assign it to a <a class="el" href="classloos_1_1_trajectory.html" title="Base-class for polymorphic trajectories.">Trajectory</a> object... </p>

</div>
</div>
<a id="a8ce914a61c5001a5a966864f758630ca" name="a8ce914a61c5001a5a966864f758630ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ce914a61c5001a5a966864f758630ca">&#9670;&#160;</a></span>deduceAtomicNumberFromMass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int loos::deduceAtomicNumberFromMass </td>
          <td>(</td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>mass</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>tolerance</em><span class="paramdefsep"> = </span><span class="paramdefval">0.1</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduce an atomic number from the mass. </p>
<p>Only the first 96 elements are included in LOOS. An atomic number of 0 is returned if the mass is not found within LOOS' table. </p>

</div>
</div>
<a id="a9938bb182cff8aeddeb0eb7aac81b09f" name="a9938bb182cff8aeddeb0eb7aac81b09f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9938bb182cff8aeddeb0eb7aac81b09f">&#9670;&#160;</a></span>invocationHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string loos::invocationHeader </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname">[]</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an invocation header. </p>
<p>This is a string that can be embedded in output that records the invoking user, command-line, and a timestamp. </p>

</div>
</div>
<a id="ab42aeab4c92169da3571c75d3f035ad5" name="ab42aeab4c92169da3571c75d3f035ad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab42aeab4c92169da3571c75d3f035ad5">&#9670;&#160;</a></span>iterativeAlignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::tuple&lt; std::vector&lt; <a class="el" href="classloos_1_1_x_form.html">XForm</a> &gt;, greal, int &gt; loos::iterativeAlignment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>model</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pTraj &amp;</td>          <td class="paramname"><span class="paramname"><em>traj</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>frame_indices</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">greal</td>          <td class="paramname"><span class="paramname"><em>threshold</em><span class="paramdefsep"> = </span><span class="paramdefval">1<a class="el" href="classloos_1_1_math_1_1_matrix.html">e</a>-6</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>maxiter</em><span class="paramdefsep"> = </span><span class="paramdefval">1000</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute an iterative superposition by reading in frames from the <a class="el" href="classloos_1_1_trajectory.html" title="Base-class for polymorphic trajectories.">Trajectory</a>. </p>
<p>The iterativeAlignment() functions that take a trajectory as an argument do NOT cache frames of the trajectory internally. This means that the trajectory will be read as many times as is necessary for the alignment to converge. In practice, the OS-specific caching will likely result in decent performance. If speed is essential, then consider using the iterativeAlignment() version that takes a <code>std::vector&lt;AtomicGroup&gt;&amp;</code> as argument instead. </p>

</div>
</div>
<a id="ad172cde7ba10cd0378d767a9c5ece776" name="ad172cde7ba10cd0378d767a9c5ece776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad172cde7ba10cd0378d767a9c5ece776">&#9670;&#160;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_coord.html">Coord</a>&lt; T &gt; loos::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_matrix44.html">Matrix44</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>M</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_coord.html">Coord</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix-vector multiply This has to be a friend outside the class for GCC to be happy... </p>

</div>
</div>
<a id="a5787a9c94567691f2bc0e5362320a92c" name="a5787a9c94567691f2bc0e5362320a92c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5787a9c94567691f2bc0e5362320a92c">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; loos::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_gromacs.html">Gromacs</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output the group as a GRO... </p>
<p>Output as a GRO. </p>

</div>
</div>
<a id="a9aa719d784c66d87513bd26d6928536b" name="a9aa719d784c66d87513bd26d6928536b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aa719d784c66d87513bd26d6928536b">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; loos::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_p_d_b.html">PDB</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output the group as a <a class="el" href="classloos_1_1_p_d_b.html" title="PDB reading/writing class.">PDB</a>... </p>
<p>Output as a <a class="el" href="classloos_1_1_p_d_b.html" title="PDB reading/writing class.">PDB</a>.</p>
<p>There are some formatting changes that occur when the group has a large number of atoms or resids. The most significant is when you have 100,000 or more, in which case you lose the altloc and chainid fields on output. However, the output <a class="el" href="classloos_1_1_p_d_b.html" title="PDB reading/writing class.">PDB</a> will load into pymol... </p>

</div>
</div>
<a id="a3a934b70913b38a1bb2aa4c0fecf32d0" name="a3a934b70913b38a1bb2aa4c0fecf32d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a934b70913b38a1bb2aa4c0fecf32d0">&#9670;&#160;</a></span>parseIndexRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classloos_1_1_math_1_1_matrix.html">uint</a> &gt; loos::parseIndexRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classloos_1_1_math_1_1_matrix.html">const</a> std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>input</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classloos_1_1_math_1_1_matrix.html">const</a> <a class="el" href="classloos_1_1_math_1_1_matrix.html">uint</a></td>          <td class="paramname"><span class="paramname"><em>maxsize</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use boost::Spirit to parse a new-style range list. </p>
<p>Similar to <a class="el" href="#a750b5d795f43978407dc4e9127c7db03" title="Parses a list of Octave-style range specifiers (for compatability)">parseRangeList()</a>, but uses boost::spirit can requires a maximum index size. This allows you to specify ranges without knowing the endpoint, e.g. 10:2:, means start at 10, skipping 2, until the value of maxsize. This is useful for trajectories, otherwise you would have to know how big they are before using a range to specify a skip and stride. </p>

</div>
</div>
<a id="a94ab4282e526a1e5cb89a7d0c2f4ef45" name="a94ab4282e526a1e5cb89a7d0c2f4ef45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94ab4282e526a1e5cb89a7d0c2f4ef45">&#9670;&#160;</a></span>parseRange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classloos_1_1_math_1_1_matrix.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; loos::parseRange </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>text</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>endpoint</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse an Octave/Matlab-style range. </p>
<p>The Octave format is one of the following:</p><ul>
<li>value</li>
<li>start:stop</li>
<li>start:step:stop</li>
</ul>
<p>The range is inclusive for both ends. Internally, a vector of T's is created. There is no checking to make sure that the vector doesn't completely fill up memory.</p>
<p>As with matlab/octave, to count down, the step must be negative and start &gt; stop. </p>

</div>
</div>
<a id="a23448ed73a24493021dd00473c70deed" name="a23448ed73a24493021dd00473c70deed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23448ed73a24493021dd00473c70deed">&#9670;&#160;</a></span>parseRangeList()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classloos_1_1_math_1_1_matrix.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; loos::parseRangeList </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>text</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>endpoint</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a comma-separated list of Octave-style ranges. </p>
<p>This function breaks apart a string at the commas and passes each substring to parseRange. The union of all of the vectors returned by parseRange is then sorted in ascending order and duplicate values are removed. This vector is then returned to the caller. </p>

</div>
</div>
<a id="a6ade6e7564c4aa077a6f3134c6252663" name="a6ade6e7564c4aa077a6f3134c6252663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ade6e7564c4aa077a6f3134c6252663">&#9670;&#160;</a></span>randomSeedRNG()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint loos::randomSeedRNG </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Randomly seeds the RNG. </p>
<p>Currently uses time(3) to seed the RNG obtained from the singleton... Returns the seed used. </p>

</div>
</div>
<a id="a946b258c3b8510b1f042fb09088b992c" name="a946b258c3b8510b1f042fb09088b992c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a946b258c3b8510b1f042fb09088b992c">&#9670;&#160;</a></span>readTable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classloos_1_1_math_1_1_matrix.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt; loos::readTable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classloos_1_1_line_reader.html">LineReader</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>reader</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read in a table of items using a <a class="el" href="classloos_1_1_line_reader.html" title="Class for reading line-by-line from a file while tracking line numbers and stripping comments.">LineReader</a> object. </p>
<p>This is distinct from the Matrix class reader which requires a specific format. Here, comments may be freely interspersed with the data and rows may contain different numbers of columns </p>

</div>
</div>
<a id="a37368a8e72cbbefae7053afdc0756c25" name="a37368a8e72cbbefae7053afdc0756c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37368a8e72cbbefae7053afdc0756c25">&#9670;&#160;</a></span>readVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classloos_1_1_math_1_1_matrix.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; loos::readVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classloos_1_1_line_reader.html">LineReader</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>reader</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a list of items using a <a class="el" href="classloos_1_1_line_reader.html" title="Class for reading line-by-line from a file while tracking line numbers and stripping comments.">LineReader</a> object. </p>
<p>The readVector&lt;T&gt;() family of functions allows you to read in a list of items (numbers) from a stream or a file. When used with a <a class="el" href="classloos_1_1_line_reader.html" title="Class for reading line-by-line from a file while tracking line numbers and stripping comments.">LineReader</a> object, you have control over how blank lines and comments are handled. When used with either an istream or a string, the default behavior is to skip blank lines and comments will begin with the '#' character and are stripped. </p>

</div>
</div>
<a id="ab82436be3d1bfa01542d6a8f3820a38b" name="ab82436be3d1bfa01542d6a8f3820a38b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab82436be3d1bfa01542d6a8f3820a38b">&#9670;&#160;</a></span>rng_singleton()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">base_generator_type &amp; loos::rng_singleton </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suite-wide random number generator singleton. </p>
<pre class="fragment"> LOOS makes no assumptions about how the random number generator
 gets seeded.  It is up to the tool-writer to seed it with a known
 value,
</pre> <div class="fragment"><div class="line"><a class="code hl_function" href="#ab82436be3d1bfa01542d6a8f3820a38b">rng_singleton</a>().seed(<a class="code hl_class" href="classloos_1_1_math_1_1_matrix.html">seed_value</a>);</div>
<div class="ttc" id="aclassloos_1_1_math_1_1_matrix_html"><div class="ttname"><a href="classloos_1_1_math_1_1_matrix.html">loos::Math::Matrix</a></div><div class="ttdoc">Simple matrix template class using policy classes to determine behavior.</div><div class="ttdef"><b>Definition</b> MatrixImpl.hpp:148</div></div>
<div class="ttc" id="anamespaceloos_html_ab82436be3d1bfa01542d6a8f3820a38b"><div class="ttname"><a href="#ab82436be3d1bfa01542d6a8f3820a38b">loos::rng_singleton</a></div><div class="ttdeci">base_generator_type &amp; rng_singleton(void)</div><div class="ttdoc">Suite-wide random number generator singleton.</div><div class="ttdef"><b>Definition</b> utils_random.cpp:27</div></div>
</div><!-- fragment --><p> or call <a class="el" href="#a6ade6e7564c4aa077a6f3134c6252663" title="Randomly seeds the RNG.">randomSeedRNG()</a> to randomly seed the random number generator... </p>

</div>
</div>
<a id="a01ad12706a6b9884cc8f3a5677a899e3" name="a01ad12706a6b9884cc8f3a5677a899e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01ad12706a6b9884cc8f3a5677a899e3">&#9670;&#160;</a></span>selectAtoms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> loos::selectAtoms </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>source</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string</td>          <td class="paramname"><span class="paramname"><em>selection</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a string-based selection to an atomic group... </p>
<p>This routine parses the passed string, turning it into a selector and applies it to <em>source</em>. If there is an exception in the parsing, this is repackaged into a more sensible error message (including the string that generated the error). No other exceptions are caught.</p>
<p>We're also assuming that you're <em>always</em> wanting to select some atoms, so lack of selection constitutes an error and an exception is thrown. Note that in both the case of a parse error and null-selection, a runtime_error exception is thrown so the catcher cannot disambiguate between the two. </p>

</div>
</div>
<a id="afcbceccb5ba3893220304b71353a9f59" name="afcbceccb5ba3893220304b71353a9f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcbceccb5ba3893220304b71353a9f59">&#9670;&#160;</a></span>sortedIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classloos_1_1_math_1_1_matrix.html">typename</a> T , <a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> SortPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint &gt; loos::sortedIndex </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort a container using the given sort policy, returning the indices that permutes the container into the sorted order. The container to be sorted must support T::size() and T::operator[]. What is returned is a vector of unsigned ints that represent the index into the container when it is sorted. </p>

</div>
</div>
<a id="a34932a929bc0953556a35766c9989471" name="a34932a929bc0953556a35766c9989471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34932a929bc0953556a35766c9989471">&#9670;&#160;</a></span>svd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::tuple&lt; <a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a>, <a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a>, <a class="el" href="classloos_1_1_math_1_1_matrix.html">RealMatrix</a> &gt; loos::svd </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ensemble</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>align</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classloos_1_1_math_1_1_matrix.html">true</a></span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the SVD of an ensemble with optional alignment (note RSVs returned are transposed) </p>
<p>Returns the U, S, and V' of the SVD of the passed ensemble. If align is true, then the ensemble is iteratively aligned prior to computing the SVD. </p>

</div>
</div>
<a id="aee1021d75b06b63e2410636b11179c1a" name="aee1021d75b06b63e2410636b11179c1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee1021d75b06b63e2410636b11179c1a">&#9670;&#160;</a></span>swab()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classloos_1_1_math_1_1_matrix.html">typename</a> T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T loos::swab </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>datum</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a byte-swapped copy of an arbitrary type. </p>
<p>Only valid for simple types (i.e. int, float, double) </p>

</div>
</div>
<a id="a1b71724c3ca8b3c7f53db1f5981d9252" name="a1b71724c3ca8b3c7f53db1f5981d9252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b71724c3ca8b3c7f53db1f5981d9252">&#9670;&#160;</a></span>writeAsciiMatrix() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> T , <a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> P , <a class="el" href="classloos_1_1_math_1_1_matrix.html">template</a>&lt; <a class="el" href="classloos_1_1_math_1_1_matrix.html">typename</a> &gt; <a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> S&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void loos::writeAsciiMatrix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>fname</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_math_1_1_matrix.html">Math::Matrix</a>&lt; T, P, S &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>M</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>meta</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>trans</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write an entire matrix to a file. </p>
<p>Principal front-end to writing out ASCII matrices. Given a filename, matrix, metadata, and optional flag for whether or not the matrix is transposed interally, will write the entire matrix using the default C++ type-to-string conversion. </p>

</div>
</div>
<a id="a0c27dfb56522a23f2522dd6019e71217" name="a0c27dfb56522a23f2522dd6019e71217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c27dfb56522a23f2522dd6019e71217">&#9670;&#160;</a></span>writeAsciiMatrix() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> T , <a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> P , <a class="el" href="classloos_1_1_math_1_1_matrix.html">template</a>&lt; <a class="el" href="classloos_1_1_math_1_1_matrix.html">typename</a> &gt; <a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> S&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; loos::writeAsciiMatrix </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_math_1_1_matrix.html">Math::Matrix</a>&lt; T, P, S &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>M</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>meta</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>trans</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write an entire matrix to a stream. </p>
<pre class="fragment"> Primary front-end to writing an entire ASCII matrix to a stream.
 Will use the default C++ type-to-string conversion for the matrix
 data type (e.g. float).
 Example:
</pre> <div class="fragment"><div class="line"><a class="code hl_class" href="classloos_1_1_math_1_1_matrix.html">Matrix&lt;double&gt;</a> M;</div>
<div class="line"><a class="code hl_function" href="#a09efd2e63b9afd3800b7776f6dc84a6e">writeAsciiMatrix</a>(cout, M, <span class="stringliteral">&quot;Eigenvector matrix&quot;</span>);</div>
<div class="ttc" id="anamespaceloos_html_a09efd2e63b9afd3800b7776f6dc84a6e"><div class="ttname"><a href="#a09efd2e63b9afd3800b7776f6dc84a6e">loos::writeAsciiMatrix</a></div><div class="ttdeci">std::ostream &amp; writeAsciiMatrix(std::ostream &amp;os, const Math::Matrix&lt; T, P, S &gt; &amp;M, const std::string &amp;meta, const Math::Range &amp;start, const Math::Range &amp;end, const bool trans=false, F fmt=F())</div><div class="ttdoc">Write a submatrix to a stream.</div><div class="ttdef"><b>Definition</b> MatrixWrite.hpp:140</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a09efd2e63b9afd3800b7776f6dc84a6e" name="a09efd2e63b9afd3800b7776f6dc84a6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09efd2e63b9afd3800b7776f6dc84a6e">&#9670;&#160;</a></span>writeAsciiMatrix() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> T , <a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> P , <a class="el" href="classloos_1_1_math_1_1_matrix.html">template</a>&lt; <a class="el" href="classloos_1_1_math_1_1_matrix.html">typename</a> &gt; <a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> S, <a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; loos::writeAsciiMatrix </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_math_1_1_matrix.html">Math::Matrix</a>&lt; T, P, S &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>M</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>meta</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceloos_1_1_math.html#ad6e4e1580b47f3f204c4ff48a6658c24">Math::Range</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>start</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceloos_1_1_math.html#ad6e4e1580b47f3f204c4ff48a6658c24">Math::Range</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>end</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>trans</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F</td>          <td class="paramname"><span class="paramname"><em>fmt</em><span class="paramdefsep"> = </span><span class="paramdefval">F()</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a submatrix to a stream. </p>
<p>This family of functions write a matrix in ASCII format suitable for loading into Octave/Matlab or gnuplot. The <em>meta</em> information is written as part of the comment at the start of the file. The <a class="el" href="namespaceloos_1_1_math.html#ad6e4e1580b47f3f204c4ff48a6658c24" title="Specify a range for columns/rows [first,second)">Math::Range</a> <em>start</em> and <em>end</em> are just pairs that give an <em></em>(j,i) starting and ending point within the matrix to write. Note that these arguments are not always honored (such as with a triangular matrix). The <em>trans</em> flag causes the output matrix to be the transpose of the stored matrix. The <em>fmt</em> arg is a functor that is expected for format each element of the matrix as a string. You can use this to adjust the precision of the output or delimit it, etc. The default is to use whatever the default operator&lt;&lt;() would be for type T. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
