#!/usr/bin/env python3
"""
cluster_pops.py: write of populations of clusters for each trajectory

Alan Grossfield, 2020
"""
"""

  This file is part of LOOS.

  LOOS (Lightweight Object-Oriented Structure library)
  Copyright (c) 2013 Tod Romo, Grossfield Lab
  Department of Biochemistry and Biophysics
  School of Medicine & Dentistry, University of Rochester

  This package (LOOS) is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation under version 3 of the License.

  This package is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.

"""




import sys
import json
import numpy
from math import sqrt
def read_frame_ranges(filename):
    filenames = []
    ends = []
    with open(filename) as f:
        # skip the first 2 lines, stop when a line doesn't start with "#"
        for line in f.readlines()[2:]:
            if line.startswith("#"):
                try:
                    hash, index, start, end, filename = line.split()
                    filenames.append(filename)
                    ends.append(int(end))
                except ValueError:
                    break
            else:
                break
    return (filenames, numpy.array(ends))


def usage():
    string = f"""
    Usage: {sys.argv[0]} json_file rmsds_file outfile [split]
        json_file:  json output from cluster-kgs
        rmsds_file: file of distances input to cluster-kgs,
                    presumably generated by rmsds or multi-rmsds
        outfile:    file of cluster populations, in numpy matrix format.
                    The shape of the matrix will be (#clusters, # trajectories)
        split:      optional integer for splitting the trajectories into
                    2 groups. For example, if you have 4 "wild type"
                    trajectories and 4 "mutant" trajectories, then
                    passing a value of 4 would print out the average
                    wild type and mutant populations, as well as the std dev
                    and std error of the populations.

    """
    return string


if __name__ == "__main__":
    if len(sys.argv) == 1 or "-h" in sys.argv:
        print(usage())
        sys.exit(0)

    header = " ".join(sys.argv)
    json_filename = sys.argv[1]
    rmsds_filename = sys.argv[2]
    out_filename = sys.argv[3]
    if len(sys.argv) > 4:
        split = int(sys.argv[4])
    else:
        split = 0

    filenames, ends = read_frame_ranges(rmsds_filename)

    with open(json_filename) as f:
        cluster_data = json.load(f)

    clusters = cluster_data['clusters']

    data = numpy.zeros((len(clusters), len(filenames)))

    for i in range(len(clusters)):
        arr = numpy.array(clusters[i])
        indices = numpy.searchsorted(ends, arr, side='right')
        indices -= 1
        for j in indices:
            data[i, j] += 1

    # normalize for each trajectory
    data /= numpy.add.reduce(data)

    # write out the matrix of populations
    numpy.savetxt(out_filename, data, header=header)

    if split:
        print("# Clust FirAve FirDev FirStdErr SecAve SecDev SecStdErr   ")
        first_mean = numpy.mean(data[:, :split], axis=1)
        first_dev = numpy.std(data[:, :split], axis=1)
        first_err = first_dev / sqrt(split)
        sec_mean = numpy.mean(data[:, split:], axis=1)
        sec_dev = numpy.std(data[:, split:], axis=1)
        sec_err = sec_dev / sqrt(len(filenames) - split)
        for i in range(len(first_mean)):
            print(i, first_mean[i], first_dev[i], first_err[i],
                  sec_mean[i], sec_dev[i], sec_err[i]
                  )
