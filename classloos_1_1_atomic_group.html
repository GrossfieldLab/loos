<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LOOS: loos::AtomicGroup Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LOOS<span id="projectnumber">&#160;4.1.0</span>
   </div>
   <div id="projectbrief">The Lightweight Object Oriented Structural analysis library/toolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceloos.html">loos</a></li><li class="navelem"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classloos_1_1_atomic_group-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">loos::AtomicGroup Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Class for handling groups of Atoms (pAtoms, actually)  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_atomic_group_8hpp_source.html">AtomicGroup.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for loos::AtomicGroup:</div>
<div class="dyncontent">
<div class="center"><img src="classloos_1_1_atomic_group__inherit__graph.png" border="0" usemap="#aloos_1_1_atomic_group_inherit__map" alt="Inheritance graph"/></div>
<map name="aloos_1_1_atomic_group_inherit__map" id="aloos_1_1_atomic_group_inherit__map">
<area shape="rect" title="Class for handling groups of Atoms (pAtoms, actually)" alt="" coords="5,179,135,204"/>
<area shape="rect" href="classloos_1_1_amber.html" title="Class for reading in AMBER parmtop/coord files..." alt="" coords="195,5,286,31"/>
<area shape="poly" title=" " alt="" coords="83,163,122,102,150,69,181,40,199,29,201,34,184,44,154,73,127,106,88,166"/>
<area shape="rect" href="classloos_1_1_c_h_a_r_m_m.html" title="Class for reading a CHARMM coordinate file." alt="" coords="183,55,298,80"/>
<area shape="poly" title=" " alt="" coords="92,165,132,127,181,89,202,78,204,83,184,94,135,131,96,169"/>
<area shape="rect" href="classloos_1_1_gromacs.html" title="Implements a GROMACS model file (.gro)" alt="" coords="187,104,294,130"/>
<area shape="poly" title=" " alt="" coords="113,170,182,138,206,128,208,133,184,143,115,174"/>
<area shape="rect" href="classloos_1_1_m_d_traj.html" title="Class for reading a MDTraj HDF5 file." alt="" coords="192,153,289,179"/>
<area shape="poly" title=" " alt="" coords="150,177,192,171,192,176,150,182"/>
<area shape="rect" href="classloos_1_1_m_m_c_i_f.html" title="Class to read pdbx/mmcif files." alt="" coords="192,203,289,228"/>
<area shape="poly" title=" " alt="" coords="151,200,192,206,191,211,150,205"/>
<area shape="rect" href="classloos_1_1_p_d_b.html" title="PDB reading/writing class." alt="" coords="200,252,281,278"/>
<area shape="poly" title=" " alt="" coords="116,208,184,238,208,249,206,254,182,243,113,213"/>
<area shape="rect" href="classloos_1_1_p_s_f.html" title="Class for reading a subset of the PSF format." alt="" coords="201,301,280,327"/>
<area shape="poly" title=" " alt="" coords="96,214,135,251,184,288,204,299,202,303,181,292,132,255,92,218"/>
<area shape="rect" href="classloos_1_1_tinker_x_y_z.html" title="Class for reading a subset of the TinkerXYZ format." alt="" coords="183,351,298,376"/>
<area shape="poly" title=" " alt="" coords="88,217,127,277,154,309,184,337,201,348,199,352,181,342,150,313,123,280,83,219"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for loos::AtomicGroup:</div>
<div class="dyncontent">
<div class="center"><img src="classloos_1_1_atomic_group__coll__graph.png" border="0" usemap="#aloos_1_1_atomic_group_coll__map" alt="Collaboration graph"/></div>
<map name="aloos_1_1_atomic_group_coll__map" id="aloos_1_1_atomic_group_coll__map">
<area shape="rect" title="Class for handling groups of Atoms (pAtoms, actually)" alt="" coords="23,94,152,120"/>
<area shape="rect" href="classloos_1_1_shared_periodic_box.html" title="This class manages a shared Periodicbox." alt="" coords="5,5,170,31"/>
<area shape="poly" title=" " alt="" coords="90,47,90,94,85,94,85,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classloos_1_1_atomic_group_1_1_iterator.html">Iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Our own simple iterator for stepping over all managed atoms.  <a href="classloos_1_1_atomic_group_1_1_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af3cf1aeeacb960a6a45f91a8ec931659" id="r_af3cf1aeeacb960a6a45f91a8ec931659"><td class="memItemLeft" align="right" valign="top"><a id="af3cf1aeeacb960a6a45f91a8ec931659" name="af3cf1aeeacb960a6a45f91a8ec931659"></a>
<a class="el" href="classloos_1_1_math_1_1_matrix.html">typedef</a> std::vector&lt; pAtom &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr class="separator:af3cf1aeeacb960a6a45f91a8ec931659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6221d23a16953e033ce19749dc011c63" id="r_a6221d23a16953e033ce19749dc011c63"><td class="memItemLeft" align="right" valign="top"><a id="a6221d23a16953e033ce19749dc011c63" name="a6221d23a16953e033ce19749dc011c63"></a>
<a class="el" href="classloos_1_1_math_1_1_matrix.html">typedef</a> std::vector&lt; pAtom &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr class="separator:a6221d23a16953e033ce19749dc011c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc0e13a72c353cf309f652aed6bff90c" id="r_afc0e13a72c353cf309f652aed6bff90c"><td class="memItemLeft" align="right" valign="top"><a id="afc0e13a72c353cf309f652aed6bff90c" name="afc0e13a72c353cf309f652aed6bff90c"></a>
<a class="el" href="classloos_1_1_math_1_1_matrix.html">typedef</a> pAtom&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr class="separator:afc0e13a72c353cf309f652aed6bff90c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a125a4b144bc5457366ae204e8f98f446" id="r_a125a4b144bc5457366ae204e8f98f446"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a125a4b144bc5457366ae204e8f98f446">AtomicGroup</a> (const int n)</td></tr>
<tr class="memdesc:a125a4b144bc5457366ae204e8f98f446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually)">AtomicGroup</a> with <em>n</em> un-initialized atoms.  <br /></td></tr>
<tr class="separator:a125a4b144bc5457366ae204e8f98f446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8a428dd6a010ab86dda09d5a461fd2" id="r_a9d8a428dd6a010ab86dda09d5a461fd2"><td class="memItemLeft" align="right" valign="top"><a id="a9d8a428dd6a010ab86dda09d5a461fd2" name="a9d8a428dd6a010ab86dda09d5a461fd2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AtomicGroup</b> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;g)</td></tr>
<tr class="memdesc:a9d8a428dd6a010ab86dda09d5a461fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor (atoms and box shared) <br /></td></tr>
<tr class="separator:a9d8a428dd6a010ab86dda09d5a461fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dcd01a7efbe31915470ff25dd337d3f" id="r_a0dcd01a7efbe31915470ff25dd337d3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0dcd01a7efbe31915470ff25dd337d3f">copy</a> (void) const</td></tr>
<tr class="memdesc:a0dcd01a7efbe31915470ff25dd337d3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a deep copy of this group.  <br /></td></tr>
<tr class="separator:a0dcd01a7efbe31915470ff25dd337d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a35c891ecf43b59745991592755ba0" id="r_a10a35c891ecf43b59745991592755ba0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10a35c891ecf43b59745991592755ba0">clone</a> (void) const</td></tr>
<tr class="memdesc:a10a35c891ecf43b59745991592755ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a lightweight clone of this group (for polymorphism)  <br /></td></tr>
<tr class="separator:a10a35c891ecf43b59745991592755ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a96e9d50eba09bba550d5dc0aa8e6a" id="r_a94a96e9d50eba09bba550d5dc0aa8e6a"><td class="memItemLeft" align="right" valign="top"><a id="a94a96e9d50eba09bba550d5dc0aa8e6a" name="a94a96e9d50eba09bba550d5dc0aa8e6a"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>length</b> (void) const</td></tr>
<tr class="separator:a94a96e9d50eba09bba550d5dc0aa8e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67298ad8de21779ee73cd030f73690ad" id="r_a67298ad8de21779ee73cd030f73690ad"><td class="memItemLeft" align="right" valign="top"><a id="a67298ad8de21779ee73cd030f73690ad" name="a67298ad8de21779ee73cd030f73690ad"></a>
uint&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> (void) const</td></tr>
<tr class="separator:a67298ad8de21779ee73cd030f73690ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4c499f752d7778e6c0bd0591954f9c" id="r_abc4c499f752d7778e6c0bd0591954f9c"><td class="memItemLeft" align="right" valign="top"><a id="abc4c499f752d7778e6c0bd0591954f9c" name="abc4c499f752d7778e6c0bd0591954f9c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>empty</b> (void) const</td></tr>
<tr class="separator:abc4c499f752d7778e6c0bd0591954f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae5cac1d07afe454e92fe25e8afb4170" id="r_aae5cac1d07afe454e92fe25e8afb4170"><td class="memItemLeft" align="right" valign="top"><a id="aae5cac1d07afe454e92fe25e8afb4170" name="aae5cac1d07afe454e92fe25e8afb4170"></a>
pAtom&#160;</td><td class="memItemRight" valign="bottom"><b>getAtom</b> (const int i) const</td></tr>
<tr class="memdesc:aae5cac1d07afe454e92fe25e8afb4170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ith atom from this group. <br /></td></tr>
<tr class="separator:aae5cac1d07afe454e92fe25e8afb4170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5fdbd8588fe478c2b6c69ab6a421400" id="r_af5fdbd8588fe478c2b6c69ab6a421400"><td class="memItemLeft" align="right" valign="top"><a id="af5fdbd8588fe478c2b6c69ab6a421400" name="af5fdbd8588fe478c2b6c69ab6a421400"></a>
pAtom &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (const int i)</td></tr>
<tr class="memdesc:af5fdbd8588fe478c2b6c69ab6a421400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as getAtom(i) <br /></td></tr>
<tr class="separator:af5fdbd8588fe478c2b6c69ab6a421400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc519a01bd492ce9ea169a380e8f113" id="r_aacc519a01bd492ce9ea169a380e8f113"><td class="memItemLeft" align="right" valign="top"><a id="aacc519a01bd492ce9ea169a380e8f113" name="aacc519a01bd492ce9ea169a380e8f113"></a>
const pAtom &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (const int i) const</td></tr>
<tr class="separator:aacc519a01bd492ce9ea169a380e8f113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e08012004afc93b5ec2f287a37f802" id="r_ad8e08012004afc93b5ec2f287a37f802"><td class="memItemLeft" align="right" valign="top"><a id="ad8e08012004afc93b5ec2f287a37f802" name="ad8e08012004afc93b5ec2f287a37f802"></a>
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>append</b> (pAtom pa)</td></tr>
<tr class="memdesc:ad8e08012004afc93b5ec2f287a37f802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the atom onto the group. <br /></td></tr>
<tr class="separator:ad8e08012004afc93b5ec2f287a37f802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a292faf9da4066b9425d0b3334bcf9e43" id="r_a292faf9da4066b9425d0b3334bcf9e43"><td class="memItemLeft" align="right" valign="top"><a id="a292faf9da4066b9425d0b3334bcf9e43" name="a292faf9da4066b9425d0b3334bcf9e43"></a>
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>append</b> (std::vector&lt; pAtom &gt; <a class="el" href="classloos_1_1_math_1_1_matrix.html">pas</a>)</td></tr>
<tr class="memdesc:a292faf9da4066b9425d0b3334bcf9e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a vector of atoms. <br /></td></tr>
<tr class="separator:a292faf9da4066b9425d0b3334bcf9e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac22f0f96ac05fbf0bc1d886bc48a73cf" id="r_ac22f0f96ac05fbf0bc1d886bc48a73cf"><td class="memItemLeft" align="right" valign="top"><a id="ac22f0f96ac05fbf0bc1d886bc48a73cf" name="ac22f0f96ac05fbf0bc1d886bc48a73cf"></a>
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>append</b> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;grp)</td></tr>
<tr class="memdesc:ac22f0f96ac05fbf0bc1d886bc48a73cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append an entire <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually)">AtomicGroup</a> onto this one (concatenation) <br /></td></tr>
<tr class="separator:ac22f0f96ac05fbf0bc1d886bc48a73cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a477882e3c6a5a3ff9215f7492555db78" id="r_a477882e3c6a5a3ff9215f7492555db78"><td class="memItemLeft" align="right" valign="top"><a id="a477882e3c6a5a3ff9215f7492555db78" name="a477882e3c6a5a3ff9215f7492555db78"></a>
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>remove</b> (pAtom pa)</td></tr>
<tr class="memdesc:a477882e3c6a5a3ff9215f7492555db78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a single atom. <br /></td></tr>
<tr class="separator:a477882e3c6a5a3ff9215f7492555db78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b74b1d9169c9a95fa152cedcd70b2d" id="r_ad5b74b1d9169c9a95fa152cedcd70b2d"><td class="memItemLeft" align="right" valign="top"><a id="ad5b74b1d9169c9a95fa152cedcd70b2d" name="ad5b74b1d9169c9a95fa152cedcd70b2d"></a>
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>remove</b> (std::vector&lt; pAtom &gt; <a class="el" href="classloos_1_1_math_1_1_matrix.html">pas</a>)</td></tr>
<tr class="memdesc:ad5b74b1d9169c9a95fa152cedcd70b2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes a set of atoms. <br /></td></tr>
<tr class="separator:ad5b74b1d9169c9a95fa152cedcd70b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae73e2cac9002750e1fd9f408b3b3547c" id="r_ae73e2cac9002750e1fd9f408b3b3547c"><td class="memItemLeft" align="right" valign="top"><a id="ae73e2cac9002750e1fd9f408b3b3547c" name="ae73e2cac9002750e1fd9f408b3b3547c"></a>
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>remove</b> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;grp)</td></tr>
<tr class="memdesc:ae73e2cac9002750e1fd9f408b3b3547c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all atoms in the passed grp that are also in the current group. <br /></td></tr>
<tr class="separator:ae73e2cac9002750e1fd9f408b3b3547c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f4f60bd3c46b587d5ecc3d481fc09c" id="r_af7f4f60bd3c46b587d5ecc3d481fc09c"><td class="memItemLeft" align="right" valign="top"><a id="af7f4f60bd3c46b587d5ecc3d481fc09c" name="af7f4f60bd3c46b587d5ecc3d481fc09c"></a>
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator+=</b> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;rhs)</td></tr>
<tr class="separator:af7f4f60bd3c46b587d5ecc3d481fc09c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b11da8e2cdc6e8a5fa0d5b1f26d854e" id="r_a0b11da8e2cdc6e8a5fa0d5b1f26d854e"><td class="memItemLeft" align="right" valign="top"><a id="a0b11da8e2cdc6e8a5fa0d5b1f26d854e" name="a0b11da8e2cdc6e8a5fa0d5b1f26d854e"></a>
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator+=</b> (const pAtom &amp;rhs)</td></tr>
<tr class="separator:a0b11da8e2cdc6e8a5fa0d5b1f26d854e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae894af21108bb06b5f1cf1aaeecdb0c7" id="r_ae894af21108bb06b5f1cf1aaeecdb0c7"><td class="memItemLeft" align="right" valign="top"><a id="ae894af21108bb06b5f1cf1aaeecdb0c7" name="ae894af21108bb06b5f1cf1aaeecdb0c7"></a>
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;rhs)</td></tr>
<tr class="separator:ae894af21108bb06b5f1cf1aaeecdb0c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3213e4858ec14a9293f107215082fa99" id="r_a3213e4858ec14a9293f107215082fa99"><td class="memItemLeft" align="right" valign="top"><a id="a3213e4858ec14a9293f107215082fa99" name="a3213e4858ec14a9293f107215082fa99"></a>
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const pAtom &amp;rhs)</td></tr>
<tr class="separator:a3213e4858ec14a9293f107215082fa99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838252229a0bae82a0c6184c4a7638ba" id="r_a838252229a0bae82a0c6184c4a7638ba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a838252229a0bae82a0c6184c4a7638ba">operator==</a> (<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;rhs)</td></tr>
<tr class="memdesc:a838252229a0bae82a0c6184c4a7638ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality test for two groups.  <br /></td></tr>
<tr class="separator:a838252229a0bae82a0c6184c4a7638ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca357a30a685ab4394d9b055d557727" id="r_a6ca357a30a685ab4394d9b055d557727"><td class="memItemLeft" align="right" valign="top"><a id="a6ca357a30a685ab4394d9b055d557727" name="a6ca357a30a685ab4394d9b055d557727"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;rhs)</td></tr>
<tr class="memdesc:a6ca357a30a685ab4394d9b055d557727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality test for two groups. <br /></td></tr>
<tr class="separator:a6ca357a30a685ab4394d9b055d557727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac96574981311e2631eeeafdce28dfce3" id="r_ac96574981311e2631eeeafdce28dfce3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac96574981311e2631eeeafdce28dfce3">operator==</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;rhs) const</td></tr>
<tr class="memdesc:ac96574981311e2631eeeafdce28dfce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality test for const groups.  <br /></td></tr>
<tr class="separator:ac96574981311e2631eeeafdce28dfce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa880722608ab65a32bc4aff0728b46ab" id="r_aa880722608ab65a32bc4aff0728b46ab"><td class="memItemLeft" align="right" valign="top"><a id="aa880722608ab65a32bc4aff0728b46ab" name="aa880722608ab65a32bc4aff0728b46ab"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;rhs) const</td></tr>
<tr class="memdesc:aa880722608ab65a32bc4aff0728b46ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality test for two groups. <br /></td></tr>
<tr class="separator:aa880722608ab65a32bc4aff0728b46ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaabbe2dcc5ce2aa4f9a46873d0d5a7e8" id="r_aaabbe2dcc5ce2aa4f9a46873d0d5a7e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaabbe2dcc5ce2aa4f9a46873d0d5a7e8">subset</a> (const int offset, const int <a class="el" href="classloos_1_1_math_1_1_matrix.html">len</a>=0)</td></tr>
<tr class="memdesc:aaabbe2dcc5ce2aa4f9a46873d0d5a7e8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="#aaabbe2dcc5ce2aa4f9a46873d0d5a7e8" title="subset() and excise() args are patterned after perl&#39;s substr...">subset()</a> and <a class="el" href="#a8f001aeb52990a0b0c992bde74053376" title="excise returns the excised atoms as a group...">excise()</a> args are patterned after perl's substr...  <br /></td></tr>
<tr class="separator:aaabbe2dcc5ce2aa4f9a46873d0d5a7e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f001aeb52990a0b0c992bde74053376" id="r_a8f001aeb52990a0b0c992bde74053376"><td class="memItemLeft" align="right" valign="top"><a id="a8f001aeb52990a0b0c992bde74053376" name="a8f001aeb52990a0b0c992bde74053376"></a>
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><b>excise</b> (const int offset, const int <a class="el" href="classloos_1_1_math_1_1_matrix.html">len</a>=0)</td></tr>
<tr class="memdesc:a8f001aeb52990a0b0c992bde74053376"><td class="mdescLeft">&#160;</td><td class="mdescRight">excise returns the excised atoms as a group... <br /></td></tr>
<tr class="separator:a8f001aeb52990a0b0c992bde74053376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1608898640569fc6633ae6e851695976" id="r_a1608898640569fc6633ae6e851695976"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> EqualsOp &gt; </td></tr>
<tr class="memitem:a1608898640569fc6633ae6e851695976"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1608898640569fc6633ae6e851695976">contains</a> (const pAtom &amp;p, const EqualsOp &amp;op) const</td></tr>
<tr class="memdesc:a1608898640569fc6633ae6e851695976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a pAtom is contained in this group using the EqualsOp atom-equality policy.  <br /></td></tr>
<tr class="separator:a1608898640569fc6633ae6e851695976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff94830c25cc3844ab98b06b38fffccf" id="r_aff94830c25cc3844ab98b06b38fffccf"><td class="memItemLeft" align="right" valign="top"><a id="aff94830c25cc3844ab98b06b38fffccf" name="aff94830c25cc3844ab98b06b38fffccf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>contains</b> (const pAtom &amp;p) const</td></tr>
<tr class="memdesc:aff94830c25cc3844ab98b06b38fffccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a pAtom is contained in this group using the <a class="el" href="structloos_1_1_atom_equals.html" title="Compares two atoms based solely on name, id, resid, resname, and segid.">AtomEquals</a> policy (ie the default comparison policy) <br /></td></tr>
<tr class="separator:aff94830c25cc3844ab98b06b38fffccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2490b2e223430be1f6e2ff7cf8cd23c3" id="r_a2490b2e223430be1f6e2ff7cf8cd23c3"><td class="memTemplParams" colspan="2"><a id="a2490b2e223430be1f6e2ff7cf8cd23c3" name="a2490b2e223430be1f6e2ff7cf8cd23c3"></a>
template&lt;<a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> EqualsOp &gt; </td></tr>
<tr class="memitem:a2490b2e223430be1f6e2ff7cf8cd23c3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>contains</b> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;g, const EqualsOp &amp;op) const</td></tr>
<tr class="memdesc:a2490b2e223430be1f6e2ff7cf8cd23c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the passed group is a subset of the current group using the EqualsOp atom-equality policy. <br /></td></tr>
<tr class="separator:a2490b2e223430be1f6e2ff7cf8cd23c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf51a429e6919ecc19a06d58fe2f96a" id="r_aadf51a429e6919ecc19a06d58fe2f96a"><td class="memItemLeft" align="right" valign="top"><a id="aadf51a429e6919ecc19a06d58fe2f96a" name="aadf51a429e6919ecc19a06d58fe2f96a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>contains</b> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;g) const</td></tr>
<tr class="memdesc:aadf51a429e6919ecc19a06d58fe2f96a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a group is a subset of the current group using the default <a class="el" href="structloos_1_1_atom_equals.html" title="Compares two atoms based solely on name, id, resid, resname, and segid.">AtomEquals</a> policy. <br /></td></tr>
<tr class="separator:aadf51a429e6919ecc19a06d58fe2f96a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfafad400ff62b3ea3e4978c738aca83" id="r_adfafad400ff62b3ea3e4978c738aca83"><td class="memTemplParams" colspan="2"><a id="adfafad400ff62b3ea3e4978c738aca83" name="adfafad400ff62b3ea3e4978c738aca83"></a>
template&lt;<a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> EqualsOp &gt; </td></tr>
<tr class="memitem:adfafad400ff62b3ea3e4978c738aca83"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>containsAny</b> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;g, const EqualsOp &amp;op) const</td></tr>
<tr class="memdesc:adfafad400ff62b3ea3e4978c738aca83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a group contains any atom. <br /></td></tr>
<tr class="separator:adfafad400ff62b3ea3e4978c738aca83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40425e4a272202ef2bf634ff9374a5a" id="r_ad40425e4a272202ef2bf634ff9374a5a"><td class="memItemLeft" align="right" valign="top"><a id="ad40425e4a272202ef2bf634ff9374a5a" name="ad40425e4a272202ef2bf634ff9374a5a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>containsAny</b> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;g) const</td></tr>
<tr class="memdesc:ad40425e4a272202ef2bf634ff9374a5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a group contains any atom using the default <a class="el" href="structloos_1_1_atom_equals.html" title="Compares two atoms based solely on name, id, resid, resname, and segid.">AtomEquals</a> policy. <br /></td></tr>
<tr class="separator:ad40425e4a272202ef2bf634ff9374a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a872a5b02eca7320f51181b5a8385e6e5" id="r_a872a5b02eca7320f51181b5a8385e6e5"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> EqualsOp &gt; </td></tr>
<tr class="memitem:a872a5b02eca7320f51181b5a8385e6e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a872a5b02eca7320f51181b5a8385e6e5">intersect</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;g, const EqualsOp &amp;op)</td></tr>
<tr class="memdesc:a872a5b02eca7320f51181b5a8385e6e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the intersection of two groups using the EqualsOp atom-equality policy.  <br /></td></tr>
<tr class="separator:a872a5b02eca7320f51181b5a8385e6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3314820bb1af318a9fbbc492a8c41d92" id="r_a3314820bb1af318a9fbbc492a8c41d92"><td class="memItemLeft" align="right" valign="top"><a id="a3314820bb1af318a9fbbc492a8c41d92" name="a3314820bb1af318a9fbbc492a8c41d92"></a>
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><b>intersect</b> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;g)</td></tr>
<tr class="memdesc:a3314820bb1af318a9fbbc492a8c41d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersection of two groups. <br /></td></tr>
<tr class="separator:a3314820bb1af318a9fbbc492a8c41d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a565774cc283d8e5e65fc486330c744f9" id="r_a565774cc283d8e5e65fc486330c744f9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> EqualsOp &gt; </td></tr>
<tr class="memitem:a565774cc283d8e5e65fc486330c744f9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a565774cc283d8e5e65fc486330c744f9">merge</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;g, const EqualsOp &amp;op)</td></tr>
<tr class="memdesc:a565774cc283d8e5e65fc486330c744f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Union of two groups using the specified atom-equality policy.  <br /></td></tr>
<tr class="separator:a565774cc283d8e5e65fc486330c744f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4f5469c4c73f9fc1c3d1ade297a913" id="r_a5e4f5469c4c73f9fc1c3d1ade297a913"><td class="memItemLeft" align="right" valign="top"><a id="a5e4f5469c4c73f9fc1c3d1ade297a913" name="a5e4f5469c4c73f9fc1c3d1ade297a913"></a>
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><b>merge</b> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;g)</td></tr>
<tr class="memdesc:a5e4f5469c4c73f9fc1c3d1ade297a913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Union of two groups using the default <a class="el" href="structloos_1_1_atom_equals.html" title="Compares two atoms based solely on name, id, resid, resname, and segid.">AtomEquals</a> atom-equality policy. <br /></td></tr>
<tr class="separator:a5e4f5469c4c73f9fc1c3d1ade297a913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1171333b2120e63b2912e703363abce6" id="r_a1171333b2120e63b2912e703363abce6"><td class="memItemLeft" align="right" valign="top"><a id="a1171333b2120e63b2912e703363abce6" name="a1171333b2120e63b2912e703363abce6"></a>
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><b>select</b> (const <a class="el" href="structloos_1_1_atom_selector.html">AtomSelector</a> &amp;sel) const</td></tr>
<tr class="memdesc:a1171333b2120e63b2912e703363abce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a group consisting of atoms for which sel predicate returns true... <br /></td></tr>
<tr class="separator:a1171333b2120e63b2912e703363abce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e465a871aaeb14915b8205ffccca62" id="r_a92e465a871aaeb14915b8205ffccca62"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92e465a871aaeb14915b8205ffccca62">splitByUniqueSegid</a> (void) const</td></tr>
<tr class="memdesc:a92e465a871aaeb14915b8205ffccca62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of AtomicGroups split from the current group based on segid.  <br /></td></tr>
<tr class="separator:a92e465a871aaeb14915b8205ffccca62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addabbd7b518de4d9518c37c9c7132d6c" id="r_addabbd7b518de4d9518c37c9c7132d6c"><td class="memItemLeft" align="right" valign="top"><a id="addabbd7b518de4d9518c37c9c7132d6c" name="addabbd7b518de4d9518c37c9c7132d6c"></a>
std::vector&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>splitByMolecule</b> (void) const</td></tr>
<tr class="memdesc:addabbd7b518de4d9518c37c9c7132d6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of AtomicGroups split based on bond connectivity. <br /></td></tr>
<tr class="separator:addabbd7b518de4d9518c37c9c7132d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafee0233afda44a00ed63d77e7f38ada" id="r_aafee0233afda44a00ed63d77e7f38ada"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aafee0233afda44a00ed63d77e7f38ada">splitByMolecule</a> (const std::string &amp;selection) const</td></tr>
<tr class="separator:aafee0233afda44a00ed63d77e7f38ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade20766165e2c4f35e639f60c44c11c4" id="r_ade20766165e2c4f35e639f60c44c11c4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade20766165e2c4f35e639f60c44c11c4">splitByResidue</a> (void) const</td></tr>
<tr class="memdesc:ade20766165e2c4f35e639f60c44c11c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of AtomicGroups, each comprising a single residue.  <br /></td></tr>
<tr class="separator:ade20766165e2c4f35e639f60c44c11c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e4cf7c5acdf4bdac96d96f4d0984fd" id="r_a18e4cf7c5acdf4bdac96d96f4d0984fd"><td class="memItemLeft" align="right" valign="top"><a id="a18e4cf7c5acdf4bdac96d96f4d0984fd" name="a18e4cf7c5acdf4bdac96d96f4d0984fd"></a>
std::map&lt; std::string, <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>splitByName</b> (void) const</td></tr>
<tr class="memdesc:a18e4cf7c5acdf4bdac96d96f4d0984fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of AtomicGroups, each containing atoms with the same name. <br /></td></tr>
<tr class="separator:a18e4cf7c5acdf4bdac96d96f4d0984fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe2abaa9ad389ffb170b72defb79056b" id="r_afe2abaa9ad389ffb170b72defb79056b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe2abaa9ad389ffb170b72defb79056b">centrifyByMolecule</a> () const</td></tr>
<tr class="memdesc:afe2abaa9ad389ffb170b72defb79056b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a group with the center of masses of contained molecules.  <br /></td></tr>
<tr class="separator:afe2abaa9ad389ffb170b72defb79056b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad52592fa49234e039d056a1c1428dfc8" id="r_ad52592fa49234e039d056a1c1428dfc8"><td class="memItemLeft" align="right" valign="top"><a id="ad52592fa49234e039d056a1c1428dfc8" name="ad52592fa49234e039d056a1c1428dfc8"></a>
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><b>centrifyByResidue</b> () const</td></tr>
<tr class="memdesc:ad52592fa49234e039d056a1c1428dfc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a group with the cente of masses of contained residues (see <a class="el" href="#afe2abaa9ad389ffb170b72defb79056b" title="Replace a group with the center of masses of contained molecules.">centrifyByMolecule()</a>) <br /></td></tr>
<tr class="separator:ad52592fa49234e039d056a1c1428dfc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3885f492e4f67f184ce4f48fe1e5ecdc" id="r_a3885f492e4f67f184ce4f48fe1e5ecdc"><td class="memItemLeft" align="right" valign="top">pAtom&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3885f492e4f67f184ce4f48fe1e5ecdc">findById</a> (const int id) const</td></tr>
<tr class="memdesc:a3885f492e4f67f184ce4f48fe1e5ecdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a contained atom by its atomid.  <br /></td></tr>
<tr class="separator:a3885f492e4f67f184ce4f48fe1e5ecdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb24aeea1945cf42f234e8597aca062" id="r_a8fb24aeea1945cf42f234e8597aca062"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8fb24aeea1945cf42f234e8597aca062">groupFromID</a> (const std::vector&lt; int &gt; &amp;<a class="el" href="classloos_1_1_math_1_1_matrix.html">id_list</a>) const</td></tr>
<tr class="memdesc:a8fb24aeea1945cf42f234e8597aca062"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new group from a vector of atomids.  <br /></td></tr>
<tr class="separator:a8fb24aeea1945cf42f234e8597aca062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d1b20cae0919effcc1a8fbb2dd7695" id="r_aa1d1b20cae0919effcc1a8fbb2dd7695"><td class="memItemLeft" align="right" valign="top"><a id="aa1d1b20cae0919effcc1a8fbb2dd7695" name="aa1d1b20cae0919effcc1a8fbb2dd7695"></a>
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><b>groupFromID</b> (const std::pair&lt; int, int &gt; &amp;<a class="el" href="classloos_1_1_math_1_1_matrix.html">id_pair</a>) const</td></tr>
<tr class="memdesc:aa1d1b20cae0919effcc1a8fbb2dd7695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new group from a pair of atomids. <br /></td></tr>
<tr class="separator:aa1d1b20cae0919effcc1a8fbb2dd7695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b5f36f01919f6b54fa410e956c02816" id="r_a0b5f36f01919f6b54fa410e956c02816"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b5f36f01919f6b54fa410e956c02816">getResidue</a> (pAtom <a class="el" href="classloos_1_1_math_1_1_matrix.html">res</a>)</td></tr>
<tr class="separator:a0b5f36f01919f6b54fa410e956c02816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b251ac0d7f67d4dc2962394c483226" id="r_ad5b251ac0d7f67d4dc2962394c483226"><td class="memItemLeft" align="right" valign="top"><a id="ad5b251ac0d7f67d4dc2962394c483226" name="ad5b251ac0d7f67d4dc2962394c483226"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>asString</b> () const</td></tr>
<tr class="separator:ad5b251ac0d7f67d4dc2962394c483226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb954f4f8e8ea1d561e79d03c4fbf6f3" id="r_adb954f4f8e8ea1d561e79d03c4fbf6f3"><td class="memItemLeft" align="right" valign="top"><a id="adb954f4f8e8ea1d561e79d03c4fbf6f3" name="adb954f4f8e8ea1d561e79d03c4fbf6f3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>renumber</b> (const int start=1, const int stride=1)</td></tr>
<tr class="memdesc:adb954f4f8e8ea1d561e79d03c4fbf6f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renumber the atomid's of the contained atoms... <br /></td></tr>
<tr class="separator:adb954f4f8e8ea1d561e79d03c4fbf6f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c831ad35cb9a144dbef28d880a49b4c" id="r_a6c831ad35cb9a144dbef28d880a49b4c"><td class="memItemLeft" align="right" valign="top"><a id="a6c831ad35cb9a144dbef28d880a49b4c" name="a6c831ad35cb9a144dbef28d880a49b4c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>minId</b> (void) const</td></tr>
<tr class="separator:a6c831ad35cb9a144dbef28d880a49b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a1ded8f45cd8699504eb364c16af1f" id="r_a14a1ded8f45cd8699504eb364c16af1f"><td class="memItemLeft" align="right" valign="top"><a id="a14a1ded8f45cd8699504eb364c16af1f" name="a14a1ded8f45cd8699504eb364c16af1f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>maxId</b> (void) const</td></tr>
<tr class="separator:a14a1ded8f45cd8699504eb364c16af1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad864d8a111815a2faca59f42f1ad76be" id="r_ad864d8a111815a2faca59f42f1ad76be"><td class="memItemLeft" align="right" valign="top"><a id="ad864d8a111815a2faca59f42f1ad76be" name="ad864d8a111815a2faca59f42f1ad76be"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>minResid</b> (void) const</td></tr>
<tr class="separator:ad864d8a111815a2faca59f42f1ad76be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2370841f0ea9b463da7255846be3db3b" id="r_a2370841f0ea9b463da7255846be3db3b"><td class="memItemLeft" align="right" valign="top"><a id="a2370841f0ea9b463da7255846be3db3b" name="a2370841f0ea9b463da7255846be3db3b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>maxResid</b> (void) const</td></tr>
<tr class="separator:a2370841f0ea9b463da7255846be3db3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8c82837e68d0ced667c6307c85092e" id="r_aea8c82837e68d0ced667c6307c85092e"><td class="memItemLeft" align="right" valign="top"><a id="aea8c82837e68d0ced667c6307c85092e" name="aea8c82837e68d0ced667c6307c85092e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>numberOfResidues</b> (void) const</td></tr>
<tr class="separator:aea8c82837e68d0ced667c6307c85092e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a817c049a26c1a9d5fbbb2eb6bd97f283" id="r_a817c049a26c1a9d5fbbb2eb6bd97f283"><td class="memItemLeft" align="right" valign="top"><a id="a817c049a26c1a9d5fbbb2eb6bd97f283" name="a817c049a26c1a9d5fbbb2eb6bd97f283"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>numberOfSegids</b> (void) const</td></tr>
<tr class="separator:a817c049a26c1a9d5fbbb2eb6bd97f283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27053134ce55273e477144d7b654e60b" id="r_a27053134ce55273e477144d7b654e60b"><td class="memItemLeft" align="right" valign="top"><a id="a27053134ce55273e477144d7b654e60b" name="a27053134ce55273e477144d7b654e60b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>allHaveProperty</b> (const <a class="el" href="classloos_1_1_atom.html#a2a758660bf774fc372bd294a3fc92e53">Atom::bits</a> &amp;<a class="el" href="classloos_1_1_math_1_1_matrix.html">property</a>) const</td></tr>
<tr class="memdesc:a27053134ce55273e477144d7b654e60b"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if all atoms in the group have the passed property(ies) <br /></td></tr>
<tr class="separator:a27053134ce55273e477144d7b654e60b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a886ebce01151b9ea19f4c2d718a077e0" id="r_a886ebce01151b9ea19f4c2d718a077e0"><td class="memItemLeft" align="right" valign="top"><a id="a886ebce01151b9ea19f4c2d718a077e0" name="a886ebce01151b9ea19f4c2d718a077e0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>anyHaveProperty</b> (const <a class="el" href="classloos_1_1_atom.html#a2a758660bf774fc372bd294a3fc92e53">Atom::bits</a> &amp;<a class="el" href="classloos_1_1_math_1_1_matrix.html">property</a>) const</td></tr>
<tr class="memdesc:a886ebce01151b9ea19f4c2d718a077e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if any atom in the group have the passed property(ies) <br /></td></tr>
<tr class="separator:a886ebce01151b9ea19f4c2d718a077e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c7abe43f0f634d9708f26abd02d2f2" id="r_a80c7abe43f0f634d9708f26abd02d2f2"><td class="memItemLeft" align="right" valign="top"><a id="a80c7abe43f0f634d9708f26abd02d2f2" name="a80c7abe43f0f634d9708f26abd02d2f2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasBonds</b> (void) const</td></tr>
<tr class="memdesc:a80c7abe43f0f634d9708f26abd02d2f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does any atom in the group have bond information??? <br /></td></tr>
<tr class="separator:a80c7abe43f0f634d9708f26abd02d2f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e9881716ea6c1afa28503f4f444642" id="r_ad8e9881716ea6c1afa28503f4f444642"><td class="memItemLeft" align="right" valign="top"><a id="ad8e9881716ea6c1afa28503f4f444642" name="ad8e9881716ea6c1afa28503f4f444642"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasCoords</b> (void) const</td></tr>
<tr class="memdesc:ad8e9881716ea6c1afa28503f4f444642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do all the atoms in the group have coordinates? <br /></td></tr>
<tr class="separator:ad8e9881716ea6c1afa28503f4f444642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a207734a7387d8aadd0ded48652ca12ea" id="r_a207734a7387d8aadd0ded48652ca12ea"><td class="memItemLeft" align="right" valign="top"><a id="a207734a7387d8aadd0ded48652ca12ea" name="a207734a7387d8aadd0ded48652ca12ea"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clearBonds</b> (void)</td></tr>
<tr class="memdesc:a207734a7387d8aadd0ded48652ca12ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove any bonding information present in contained atoms. <br /></td></tr>
<tr class="separator:a207734a7387d8aadd0ded48652ca12ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab682d7a74a46a65d920f0e362bc72c5a" id="r_ab682d7a74a46a65d920f0e362bc72c5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab682d7a74a46a65d920f0e362bc72c5a">pruneBonds</a> ()</td></tr>
<tr class="memdesc:ab682d7a74a46a65d920f0e362bc72c5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to prune connectivity (only retain bonds to atoms within this <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually)">AtomicGroup</a>)  <br /></td></tr>
<tr class="separator:ab682d7a74a46a65d920f0e362bc72c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b461aac137353d384db9098e8e2433b" id="r_a6b461aac137353d384db9098e8e2433b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b461aac137353d384db9098e8e2433b">resetAtomIndices</a> ()</td></tr>
<tr class="memdesc:a6b461aac137353d384db9098e8e2433b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the atom indices (used for interfacing with trajectories)  <br /></td></tr>
<tr class="separator:a6b461aac137353d384db9098e8e2433b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf2ee4a474c487db2dab7651ddb5204" id="r_afbf2ee4a474c487db2dab7651ddb5204"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afbf2ee4a474c487db2dab7651ddb5204">deduceAtomicNumberFromMass</a> (const double tol=0.1)</td></tr>
<tr class="memdesc:afbf2ee4a474c487db2dab7651ddb5204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce atomic number from mass (if present), returning number of atoms assigned.  <br /></td></tr>
<tr class="separator:afbf2ee4a474c487db2dab7651ddb5204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fea45f0ae0d06af4a27e1c9cd159763" id="r_a7fea45f0ae0d06af4a27e1c9cd159763"><td class="memItemLeft" align="right" valign="top"><a id="a7fea45f0ae0d06af4a27e1c9cd159763" name="a7fea45f0ae0d06af4a27e1c9cd159763"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>deduceMassFromAtomicNumber</b> ()</td></tr>
<tr class="memdesc:a7fea45f0ae0d06af4a27e1c9cd159763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduce mass from atomic number (if present), returning the number of atoms assigned. <br /></td></tr>
<tr class="separator:a7fea45f0ae0d06af4a27e1c9cd159763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada45a9d3f6a1e27b4d1b5955be65dfc5" id="r_ada45a9d3f6a1e27b4d1b5955be65dfc5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada45a9d3f6a1e27b4d1b5955be65dfc5">sorted</a> (void) const</td></tr>
<tr class="memdesc:ada45a9d3f6a1e27b4d1b5955be65dfc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the array of atoms already sorted???  <br /></td></tr>
<tr class="separator:ada45a9d3f6a1e27b4d1b5955be65dfc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4df4c4e55665b8c6f8d09fc467fc35c" id="r_ae4df4c4e55665b8c6f8d09fc467fc35c"><td class="memItemLeft" align="right" valign="top"><a id="ae4df4c4e55665b8c6f8d09fc467fc35c" name="ae4df4c4e55665b8c6f8d09fc467fc35c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>sort</b> (void)</td></tr>
<tr class="memdesc:ae4df4c4e55665b8c6f8d09fc467fc35c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort based on atomid. <br /></td></tr>
<tr class="separator:ae4df4c4e55665b8c6f8d09fc467fc35c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aed84043a9af6ec6217b7c0b6b041df" id="r_a1aed84043a9af6ec6217b7c0b6b041df"><td class="memItemLeft" align="right" valign="top"><a id="a1aed84043a9af6ec6217b7c0b6b041df" name="a1aed84043a9af6ec6217b7c0b6b041df"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isPeriodic</b> (void) const</td></tr>
<tr class="memdesc:a1aed84043a9af6ec6217b7c0b6b041df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether or not periodic boundary conditions are set. <br /></td></tr>
<tr class="separator:a1aed84043a9af6ec6217b7c0b6b041df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6b8769575bff01cf96bd283a32d029" id="r_a5b6b8769575bff01cf96bd283a32d029"><td class="memItemLeft" align="right" valign="top"><a id="a5b6b8769575bff01cf96bd283a32d029" name="a5b6b8769575bff01cf96bd283a32d029"></a>
<a class="el" href="classloos_1_1_coord.html">GCoord</a>&#160;</td><td class="memItemRight" valign="bottom"><b>periodicBox</b> (void) const</td></tr>
<tr class="memdesc:a5b6b8769575bff01cf96bd283a32d029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the periodic boundary conditions. <br /></td></tr>
<tr class="separator:a5b6b8769575bff01cf96bd283a32d029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9eab6e6bae0c319d8534b0f0cc3215" id="r_aeb9eab6e6bae0c319d8534b0f0cc3215"><td class="memItemLeft" align="right" valign="top"><a id="aeb9eab6e6bae0c319d8534b0f0cc3215" name="aeb9eab6e6bae0c319d8534b0f0cc3215"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>periodicBox</b> (const <a class="el" href="classloos_1_1_coord.html">GCoord</a> &amp;c)</td></tr>
<tr class="memdesc:aeb9eab6e6bae0c319d8534b0f0cc3215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the periodic boundary conditions. <br /></td></tr>
<tr class="separator:aeb9eab6e6bae0c319d8534b0f0cc3215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e9fc4b412353e46cd78a390494c221" id="r_a94e9fc4b412353e46cd78a390494c221"><td class="memItemLeft" align="right" valign="top"><a id="a94e9fc4b412353e46cd78a390494c221" name="a94e9fc4b412353e46cd78a390494c221"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>periodicBox</b> (const greal x, const greal y, const greal z)</td></tr>
<tr class="memdesc:a94e9fc4b412353e46cd78a390494c221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the periodic boundary conditions. <br /></td></tr>
<tr class="separator:a94e9fc4b412353e46cd78a390494c221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01c3e3e1bf3dc644490839dbec64d74" id="r_aa01c3e3e1bf3dc644490839dbec64d74"><td class="memItemLeft" align="right" valign="top"><a id="aa01c3e3e1bf3dc644490839dbec64d74" name="aa01c3e3e1bf3dc644490839dbec64d74"></a>
const greal&#160;</td><td class="memItemRight" valign="bottom"><b>ocf</b> (uint offset)</td></tr>
<tr class="memdesc:aa01c3e3e1bf3dc644490839dbec64d74"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute OCF for all atom-pairs in AG of distance offset from one another <br /></td></tr>
<tr class="separator:aa01c3e3e1bf3dc644490839dbec64d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a323e20bb3a5f079a360143356aab8f" id="r_a5a323e20bb3a5f079a360143356aab8f"><td class="memItemLeft" align="right" valign="top"><a id="a5a323e20bb3a5f079a360143356aab8f" name="a5a323e20bb3a5f079a360143356aab8f"></a>
<a class="el" href="classloos_1_1_shared_periodic_box.html">loos::SharedPeriodicBox</a>&#160;</td><td class="memItemRight" valign="bottom"><b>sharedPeriodicBox</b> () const</td></tr>
<tr class="memdesc:a5a323e20bb3a5f079a360143356aab8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide access to the underlying shared periodic box... <br /></td></tr>
<tr class="separator:a5a323e20bb3a5f079a360143356aab8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49a8d5a7e61d51d7e4c3d2fd129030a" id="r_ac49a8d5a7e61d51d7e4c3d2fd129030a"><td class="memItemLeft" align="right" valign="top"><a id="ac49a8d5a7e61d51d7e4c3d2fd129030a" name="ac49a8d5a7e61d51d7e4c3d2fd129030a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>removePeriodicBox</b> ()</td></tr>
<tr class="memdesc:ac49a8d5a7e61d51d7e4c3d2fd129030a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove periodicity. <br /></td></tr>
<tr class="separator:ac49a8d5a7e61d51d7e4c3d2fd129030a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8d3c09032f4d4779681353f3b60446" id="r_a7d8d3c09032f4d4779681353f3b60446"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d8d3c09032f4d4779681353f3b60446">reimage</a> ()</td></tr>
<tr class="separator:a7d8d3c09032f4d4779681353f3b60446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2a62540a7bceaecc4231cd8948ba6c" id="r_abf2a62540a7bceaecc4231cd8948ba6c"><td class="memItemLeft" align="right" valign="top"><a id="abf2a62540a7bceaecc4231cd8948ba6c" name="abf2a62540a7bceaecc4231cd8948ba6c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reimageByAtom</b> ()</td></tr>
<tr class="memdesc:abf2a62540a7bceaecc4231cd8948ba6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reimage atoms individually into the primary cell. <br /></td></tr>
<tr class="separator:abf2a62540a7bceaecc4231cd8948ba6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8224e853282a81e55ca83fc8594cd80" id="r_ab8224e853282a81e55ca83fc8594cd80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8224e853282a81e55ca83fc8594cd80">mergeImage</a> (pAtom &amp;p)</td></tr>
<tr class="memdesc:ab8224e853282a81e55ca83fc8594cd80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a group that's split across a periodic boundary and reimages it so it's all together.  <br /></td></tr>
<tr class="separator:ab8224e853282a81e55ca83fc8594cd80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b136bf681b267e113c35a6651cbfe51" id="r_a4b136bf681b267e113c35a6651cbfe51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b136bf681b267e113c35a6651cbfe51">mergeImage</a> ()</td></tr>
<tr class="memdesc:a4b136bf681b267e113c35a6651cbfe51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a group that's split across a periodic boundary and reimages it so it's all together, using the first atom in the <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually)">AtomicGroup</a> as the reference.  <br /></td></tr>
<tr class="separator:a4b136bf681b267e113c35a6651cbfe51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa55ca365dd583fd5a663e156f3ced0c6" id="r_aa55ca365dd583fd5a663e156f3ced0c6"><td class="memItemLeft" align="right" valign="top"><a id="aa55ca365dd583fd5a663e156f3ced0c6" name="aa55ca365dd583fd5a663e156f3ced0c6"></a>
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><b>within</b> (const double dist, <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;grp) const</td></tr>
<tr class="memdesc:aa55ca365dd583fd5a663e156f3ced0c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find atoms in the current group that are within <em>dist</em> angstroms of any atom in <em>grp</em>. <br /></td></tr>
<tr class="separator:aa55ca365dd583fd5a663e156f3ced0c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475cd4daad30dde2e980c5320d0df281" id="r_a475cd4daad30dde2e980c5320d0df281"><td class="memItemLeft" align="right" valign="top"><a id="a475cd4daad30dde2e980c5320d0df281" name="a475cd4daad30dde2e980c5320d0df281"></a>
<a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a>&#160;</td><td class="memItemRight" valign="bottom"><b>within</b> (const double dist, <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;grp, const <a class="el" href="classloos_1_1_coord.html">GCoord</a> &amp;box) const</td></tr>
<tr class="memdesc:a475cd4daad30dde2e980c5320d0df281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find atoms in <em>grp</em> that are within <em>dist</em> angstroms of atoms in the current group, considering periodicity. <br /></td></tr>
<tr class="separator:a475cd4daad30dde2e980c5320d0df281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff9fcfd9ddc21f9c22f3f37757b0c4e" id="r_abff9fcfd9ddc21f9c22f3f37757b0c4e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abff9fcfd9ddc21f9c22f3f37757b0c4e">contactWith</a> (const double dist, const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;grp, const uint min=1) const</td></tr>
<tr class="memdesc:abff9fcfd9ddc21f9c22f3f37757b0c4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if any atom of current group is within <em>dist</em> angstroms of <em>grp</em>.  <br /></td></tr>
<tr class="separator:abff9fcfd9ddc21f9c22f3f37757b0c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd13acd542df91d1190854f6b270556d" id="r_afd13acd542df91d1190854f6b270556d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd13acd542df91d1190854f6b270556d">contactWith</a> (const double dist, const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;grp, const <a class="el" href="classloos_1_1_coord.html">GCoord</a> &amp;box, const uint min=1) const</td></tr>
<tr class="memdesc:afd13acd542df91d1190854f6b270556d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if any atom of current group is within <em>dist</em> angstroms of <em>grp</em>.  <br /></td></tr>
<tr class="separator:afd13acd542df91d1190854f6b270556d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154ec92f05ab911c073181d0a34d68ec" id="r_a154ec92f05ab911c073181d0a34d68ec"><td class="memItemLeft" align="right" valign="top"><a id="a154ec92f05ab911c073181d0a34d68ec" name="a154ec92f05ab911c073181d0a34d68ec"></a>
std::vector&lt; std::pair&lt; int, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getBondsIDs</b> () const</td></tr>
<tr class="memdesc:a154ec92f05ab911c073181d0a34d68ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a list of atom ID pairs that correspond to all unique bonds. <br /></td></tr>
<tr class="separator:a154ec92f05ab911c073181d0a34d68ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af23af00b109f524ed3ef958d6d899553" id="r_af23af00b109f524ed3ef958d6d899553"><td class="memItemLeft" align="right" valign="top"><a id="af23af00b109f524ed3ef958d6d899553" name="af23af00b109f524ed3ef958d6d899553"></a>
std::vector&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getBondsAGs</b> () const</td></tr>
<tr class="memdesc:af23af00b109f524ed3ef958d6d899553"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a list of atom index pairs corresponding to all unique bonds. <br /></td></tr>
<tr class="separator:af23af00b109f524ed3ef958d6d899553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b5b12845449dddc4df4cc16fa89b30" id="r_a27b5b12845449dddc4df4cc16fa89b30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27b5b12845449dddc4df4cc16fa89b30">findBonds</a> (const double dist, const <a class="el" href="classloos_1_1_coord.html">GCoord</a> &amp;box)</td></tr>
<tr class="memdesc:a27b5b12845449dddc4df4cc16fa89b30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distance-based search for bonds.  <br /></td></tr>
<tr class="separator:a27b5b12845449dddc4df4cc16fa89b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbcefc179e187903d3fb8da078d0cf06" id="r_adbcefc179e187903d3fb8da078d0cf06"><td class="memItemLeft" align="right" valign="top"><a id="adbcefc179e187903d3fb8da078d0cf06" name="adbcefc179e187903d3fb8da078d0cf06"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>findBonds</b> (const double dist)</td></tr>
<tr class="separator:adbcefc179e187903d3fb8da078d0cf06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a19e2fab6532d68291b5cc7aaf6efef" id="r_a6a19e2fab6532d68291b5cc7aaf6efef"><td class="memItemLeft" align="right" valign="top"><a id="a6a19e2fab6532d68291b5cc7aaf6efef" name="a6a19e2fab6532d68291b5cc7aaf6efef"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>findBonds</b> (const <a class="el" href="classloos_1_1_coord.html">GCoord</a> &amp;box)</td></tr>
<tr class="separator:a6a19e2fab6532d68291b5cc7aaf6efef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb13cb00e25462f1555191da339f691" id="r_a0bb13cb00e25462f1555191da339f691"><td class="memItemLeft" align="right" valign="top"><a id="a0bb13cb00e25462f1555191da339f691" name="a0bb13cb00e25462f1555191da339f691"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>findBonds</b> ()</td></tr>
<tr class="separator:a0bb13cb00e25462f1555191da339f691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300ee7d7bb26e246c1cd78829191a4fd" id="r_a300ee7d7bb26e246c1cd78829191a4fd"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> T &gt; </td></tr>
<tr class="memitem:a300ee7d7bb26e246c1cd78829191a4fd"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a300ee7d7bb26e246c1cd78829191a4fd">apply</a> (T func)</td></tr>
<tr class="memdesc:a300ee7d7bb26e246c1cd78829191a4fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a functor or a function to each atom in the group.  <br /></td></tr>
<tr class="separator:a300ee7d7bb26e246c1cd78829191a4fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd5a8cc5a6d1fe8f391b1782d008007" id="r_abbd5a8cc5a6d1fe8f391b1782d008007"><td class="memItemLeft" align="right" valign="top"><a id="abbd5a8cc5a6d1fe8f391b1782d008007" name="abbd5a8cc5a6d1fe8f391b1782d008007"></a>
iterator&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> (void)</td></tr>
<tr class="separator:abbd5a8cc5a6d1fe8f391b1782d008007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c0bb921cb2484cec7ad8054fa64e7c" id="r_ae6c0bb921cb2484cec7ad8054fa64e7c"><td class="memItemLeft" align="right" valign="top"><a id="ae6c0bb921cb2484cec7ad8054fa64e7c" name="ae6c0bb921cb2484cec7ad8054fa64e7c"></a>
iterator&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> (void)</td></tr>
<tr class="separator:ae6c0bb921cb2484cec7ad8054fa64e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4456039aa05022e3e2e8e6786c3a9278" id="r_a4456039aa05022e3e2e8e6786c3a9278"><td class="memItemLeft" align="right" valign="top"><a id="a4456039aa05022e3e2e8e6786c3a9278" name="a4456039aa05022e3e2e8e6786c3a9278"></a>
const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> (void) const</td></tr>
<tr class="separator:a4456039aa05022e3e2e8e6786c3a9278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae5b30bc810d3dd9937d1e24fb396ad" id="r_abae5b30bc810d3dd9937d1e24fb396ad"><td class="memItemLeft" align="right" valign="top"><a id="abae5b30bc810d3dd9937d1e24fb396ad" name="abae5b30bc810d3dd9937d1e24fb396ad"></a>
const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> (void) const</td></tr>
<tr class="separator:abae5b30bc810d3dd9937d1e24fb396ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159dd8fcf36911e4a3f95f701bb9cf9d" id="r_a159dd8fcf36911e4a3f95f701bb9cf9d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classloos_1_1_coord.html">GCoord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a159dd8fcf36911e4a3f95f701bb9cf9d">boundingBox</a> (void) const</td></tr>
<tr class="memdesc:a159dd8fcf36911e4a3f95f701bb9cf9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounding box for the group...  <br /></td></tr>
<tr class="separator:a159dd8fcf36911e4a3f95f701bb9cf9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429f96e9a94724ec68796f4c856f76b5" id="r_a429f96e9a94724ec68796f4c856f76b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classloos_1_1_coord.html">GCoord</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a429f96e9a94724ec68796f4c856f76b5">centerAtOrigin</a> (void)</td></tr>
<tr class="memdesc:a429f96e9a94724ec68796f4c856f76b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates the group so that the centroid is at the origin.  <br /></td></tr>
<tr class="separator:a429f96e9a94724ec68796f4c856f76b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a83f0a04b7b4bf45291c186b29859d1" id="r_a0a83f0a04b7b4bf45291c186b29859d1"><td class="memItemLeft" align="right" valign="top"><a id="a0a83f0a04b7b4bf45291c186b29859d1" name="a0a83f0a04b7b4bf45291c186b29859d1"></a>
<a class="el" href="classloos_1_1_coord.html">GCoord</a>&#160;</td><td class="memItemRight" valign="bottom"><b>centroid</b> (void) const</td></tr>
<tr class="memdesc:a0a83f0a04b7b4bf45291c186b29859d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Centroid of atoms (ignores mass, operates in group coordinates) <br /></td></tr>
<tr class="separator:a0a83f0a04b7b4bf45291c186b29859d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4189af9a4ace2bfc2921bb1d57c044d9" id="r_a4189af9a4ace2bfc2921bb1d57c044d9"><td class="memItemLeft" align="right" valign="top">greal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4189af9a4ace2bfc2921bb1d57c044d9">radius</a> (const bool <a class="el" href="classloos_1_1_math_1_1_matrix.html">use_atom_as_reference</a>=<a class="el" href="classloos_1_1_math_1_1_matrix.html">false</a>) const</td></tr>
<tr class="memdesc:a4189af9a4ace2bfc2921bb1d57c044d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum radius from centroid of all atoms (not gyration)  <br /></td></tr>
<tr class="separator:a4189af9a4ace2bfc2921bb1d57c044d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b860f2e9cde859feb85ea349b6091d" id="r_a76b860f2e9cde859feb85ea349b6091d"><td class="memItemLeft" align="right" valign="top"><a id="a76b860f2e9cde859feb85ea349b6091d" name="a76b860f2e9cde859feb85ea349b6091d"></a>
<a class="el" href="classloos_1_1_coord.html">GCoord</a>&#160;</td><td class="memItemRight" valign="bottom"><b>centerOfMass</b> (void) const</td></tr>
<tr class="memdesc:a76b860f2e9cde859feb85ea349b6091d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Center of mass of the group (in group coordinates) <br /></td></tr>
<tr class="separator:a76b860f2e9cde859feb85ea349b6091d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d8bb943f6828d5d71fcbec257d5106" id="r_a06d8bb943f6828d5d71fcbec257d5106"><td class="memItemLeft" align="right" valign="top"><a id="a06d8bb943f6828d5d71fcbec257d5106" name="a06d8bb943f6828d5d71fcbec257d5106"></a>
<a class="el" href="classloos_1_1_coord.html">GCoord</a>&#160;</td><td class="memItemRight" valign="bottom"><b>centerOfElectrons</b> (void) const</td></tr>
<tr class="memdesc:a06d8bb943f6828d5d71fcbec257d5106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analogous to center of mass. <br /></td></tr>
<tr class="separator:a06d8bb943f6828d5d71fcbec257d5106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7738691cbef8a3fc232f502f6b5ad22" id="r_ac7738691cbef8a3fc232f502f6b5ad22"><td class="memItemLeft" align="right" valign="top"><a id="ac7738691cbef8a3fc232f502f6b5ad22" name="ac7738691cbef8a3fc232f502f6b5ad22"></a>
<a class="el" href="classloos_1_1_coord.html">GCoord</a>&#160;</td><td class="memItemRight" valign="bottom"><b>dipoleMoment</b> (void) const</td></tr>
<tr class="memdesc:ac7738691cbef8a3fc232f502f6b5ad22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dipole moment, relative to group's centroid. <br /></td></tr>
<tr class="separator:ac7738691cbef8a3fc232f502f6b5ad22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd9d30e0bfffafa4424a4aed1189299d" id="r_afd9d30e0bfffafa4424a4aed1189299d"><td class="memItemLeft" align="right" valign="top"><a id="afd9d30e0bfffafa4424a4aed1189299d" name="afd9d30e0bfffafa4424a4aed1189299d"></a>
greal&#160;</td><td class="memItemRight" valign="bottom"><b>totalCharge</b> (void) const</td></tr>
<tr class="separator:afd9d30e0bfffafa4424a4aed1189299d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cda2893a1c5272e7f7d391a355557ea" id="r_a2cda2893a1c5272e7f7d391a355557ea"><td class="memItemLeft" align="right" valign="top"><a id="a2cda2893a1c5272e7f7d391a355557ea" name="a2cda2893a1c5272e7f7d391a355557ea"></a>
greal&#160;</td><td class="memItemRight" valign="bottom"><b>totalMass</b> (void) const</td></tr>
<tr class="separator:a2cda2893a1c5272e7f7d391a355557ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f5f518e25541c23f7908933cad6080" id="r_aa3f5f518e25541c23f7908933cad6080"><td class="memItemLeft" align="right" valign="top"><a id="aa3f5f518e25541c23f7908933cad6080" name="aa3f5f518e25541c23f7908933cad6080"></a>
greal&#160;</td><td class="memItemRight" valign="bottom"><b>radiusOfGyration</b> (void) const</td></tr>
<tr class="separator:aa3f5f518e25541c23f7908933cad6080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df78cdd3e971e60d49e3b840680148a" id="r_a8df78cdd3e971e60d49e3b840680148a"><td class="memItemLeft" align="right" valign="top">greal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8df78cdd3e971e60d49e3b840680148a">sphericalVariance</a> (const pAtom) const</td></tr>
<tr class="memdesc:a8df78cdd3e971e60d49e3b840680148a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spherical variance of group with respect to target atom.  <br /></td></tr>
<tr class="separator:a8df78cdd3e971e60d49e3b840680148a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee4cb2d8d752f2019eb798596a9afb8" id="r_a7ee4cb2d8d752f2019eb798596a9afb8"><td class="memItemLeft" align="right" valign="top"><a id="a7ee4cb2d8d752f2019eb798596a9afb8" name="a7ee4cb2d8d752f2019eb798596a9afb8"></a>
greal&#160;</td><td class="memItemRight" valign="bottom"><b>sphericalVariance</b> (const <a class="el" href="classloos_1_1_coord.html">GCoord</a>) const</td></tr>
<tr class="separator:a7ee4cb2d8d752f2019eb798596a9afb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea78b92c137a2639d8c83d89448d6cb" id="r_acea78b92c137a2639d8c83d89448d6cb"><td class="memItemLeft" align="right" valign="top">greal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acea78b92c137a2639d8c83d89448d6cb">stacking</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;, const <a class="el" href="classloos_1_1_coord.html">GCoord</a> &amp;box, const double threshold) const</td></tr>
<tr class="memdesc:acea78b92c137a2639d8c83d89448d6cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate stacking, as between two nucleobases.  <br /></td></tr>
<tr class="separator:acea78b92c137a2639d8c83d89448d6cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a727648708aee3f4a3af63aa76cc9b73f" id="r_a727648708aee3f4a3af63aa76cc9b73f"><td class="memItemLeft" align="right" valign="top">greal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a727648708aee3f4a3af63aa76cc9b73f">rmsd</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;)</td></tr>
<tr class="memdesc:a727648708aee3f4a3af63aa76cc9b73f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the RMSD between two groups.  <br /></td></tr>
<tr class="separator:a727648708aee3f4a3af63aa76cc9b73f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb7901950b11a6f06080ee338bd53b72" id="r_abb7901950b11a6f06080ee338bd53b72"><td class="memItemLeft" align="right" valign="top">greal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb7901950b11a6f06080ee338bd53b72">kineticEnergy</a> ()</td></tr>
<tr class="memdesc:abb7901950b11a6f06080ee338bd53b72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute kinetic energy of group.  <br /></td></tr>
<tr class="separator:abb7901950b11a6f06080ee338bd53b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c75544e38f86bd7d34d7f1a447b0df" id="r_a94c75544e38f86bd7d34d7f1a447b0df"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classloos_1_1_coord.html">GCoord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94c75544e38f86bd7d34d7f1a447b0df">getTransformedCoords</a> (const <a class="el" href="classloos_1_1_x_form.html">XForm</a> &amp;) const</td></tr>
<tr class="memdesc:a94c75544e38f86bd7d34d7f1a447b0df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of coordinates transformed by the passed <a class="el" href="classloos_1_1_x_form.html" title="Matrix class for handling coordinate transforms...">XForm</a>.  <br /></td></tr>
<tr class="separator:a94c75544e38f86bd7d34d7f1a447b0df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e479d941d1ef160286bedecde57330" id="r_a27e479d941d1ef160286bedecde57330"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classloos_1_1_coord.html">GCoord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27e479d941d1ef160286bedecde57330">differenceVectors</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;other)</td></tr>
<tr class="memdesc:a27e479d941d1ef160286bedecde57330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute difference vectors between two AtomicGroups.  <br /></td></tr>
<tr class="separator:a27e479d941d1ef160286bedecde57330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a093499187c8cb7e4c919ce36e7b873ab" id="r_a093499187c8cb7e4c919ce36e7b873ab"><td class="memItemLeft" align="right" valign="top"><a id="a093499187c8cb7e4c919ce36e7b873ab" name="a093499187c8cb7e4c919ce36e7b873ab"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>translate</b> (const <a class="el" href="classloos_1_1_coord.html">GCoord</a> &amp;v)</td></tr>
<tr class="memdesc:a093499187c8cb7e4c919ce36e7b873ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate an atomic group by vector v. <br /></td></tr>
<tr class="separator:a093499187c8cb7e4c919ce36e7b873ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d3e12ceabe2ce225fa263db16884a4" id="r_ac5d3e12ceabe2ce225fa263db16884a4"><td class="memItemLeft" align="right" valign="top"><a id="ac5d3e12ceabe2ce225fa263db16884a4" name="ac5d3e12ceabe2ce225fa263db16884a4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>rotate</b> (const <a class="el" href="classloos_1_1_coord.html">GCoord</a> &amp;<a class="el" href="classloos_1_1_math_1_1_matrix.html">axis</a>, const greal <a class="el" href="classloos_1_1_math_1_1_matrix.html">angle_in_degrees</a>)</td></tr>
<tr class="memdesc:ac5d3e12ceabe2ce225fa263db16884a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate group's coordinates (right-handed, about centroid) <br /></td></tr>
<tr class="separator:ac5d3e12ceabe2ce225fa263db16884a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52542da1e67eeb3a14fd8ecf2c7a8c87" id="r_a52542da1e67eeb3a14fd8ecf2c7a8c87"><td class="memItemLeft" align="right" valign="top"><a id="a52542da1e67eeb3a14fd8ecf2c7a8c87" name="a52542da1e67eeb3a14fd8ecf2c7a8c87"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>applyTransform</b> (const <a class="el" href="classloos_1_1_x_form.html">XForm</a> &amp;)</td></tr>
<tr class="memdesc:a52542da1e67eeb3a14fd8ecf2c7a8c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the given transform to the group's coordinates... <br /></td></tr>
<tr class="separator:a52542da1e67eeb3a14fd8ecf2c7a8c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a358e1edc74a57218e6261ab7692c5ef6" id="r_a358e1edc74a57218e6261ab7692c5ef6"><td class="memItemLeft" align="right" valign="top"><a id="a358e1edc74a57218e6261ab7692c5ef6" name="a358e1edc74a57218e6261ab7692c5ef6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>copyCoordinatesWithIndex</b> (const std::vector&lt; <a class="el" href="classloos_1_1_coord.html">GCoord</a> &gt; &amp;coords)</td></tr>
<tr class="memdesc:a358e1edc74a57218e6261ab7692c5ef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy coordinates from a vector of GCoords using the atom index as an index into the vector. <br /></td></tr>
<tr class="separator:a358e1edc74a57218e6261ab7692c5ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c5a37ae808c139a54eb8049601ffc85" id="r_a4c5a37ae808c139a54eb8049601ffc85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c5a37ae808c139a54eb8049601ffc85">copyVelocitiesWithIndex</a> (const std::vector&lt; <a class="el" href="classloos_1_1_coord.html">GCoord</a> &gt; &amp;velocities)</td></tr>
<tr class="memdesc:a4c5a37ae808c139a54eb8049601ffc85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy velocities from a vector of GCoords using the atom index as an index into the vector.  <br /></td></tr>
<tr class="separator:a4c5a37ae808c139a54eb8049601ffc85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922415f440fece32f23da2103cdc8d0d" id="r_a922415f440fece32f23da2103cdc8d0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a922415f440fece32f23da2103cdc8d0d">copyCoordinatesFrom</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;g, const uint offset=0, const uint length=0)</td></tr>
<tr class="memdesc:a922415f440fece32f23da2103cdc8d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy coordinates from g into current group.  <br /></td></tr>
<tr class="separator:a922415f440fece32f23da2103cdc8d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c50256c66c58e818df2090b1cdce05c" id="r_a6c50256c66c58e818df2090b1cdce05c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c50256c66c58e818df2090b1cdce05c">atomOrderMapFrom</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;g)</td></tr>
<tr class="memdesc:a6c50256c66c58e818df2090b1cdce05c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map the order of atoms in <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually)">AtomicGroup</a> g into the current group.  <br /></td></tr>
<tr class="separator:a6c50256c66c58e818df2090b1cdce05c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fd03b1c9bfad1e983b3c616350304cf" id="r_a3fd03b1c9bfad1e983b3c616350304cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3fd03b1c9bfad1e983b3c616350304cf">copyMappedCoordinatesFrom</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;g, const std::vector&lt; uint &gt; &amp;<a class="el" href="classloos_1_1_math_1_1_matrix.html">order</a>)</td></tr>
<tr class="memdesc:a3fd03b1c9bfad1e983b3c616350304cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a mapping of atom order, copy the coordinates into the current group.  <br /></td></tr>
<tr class="separator:a3fd03b1c9bfad1e983b3c616350304cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a3a1163fdcd8234a4e78dda2fb9bf0e" id="r_a5a3a1163fdcd8234a4e78dda2fb9bf0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a3a1163fdcd8234a4e78dda2fb9bf0e">copyMappedCoordinatesFrom</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;g)</td></tr>
<tr class="memdesc:a5a3a1163fdcd8234a4e78dda2fb9bf0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the coordinates from the group mapping the atom order.  <br /></td></tr>
<tr class="separator:a5a3a1163fdcd8234a4e78dda2fb9bf0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd02e8969d6e05ea36e5531014d72084" id="r_afd02e8969d6e05ea36e5531014d72084"><td class="memItemLeft" align="right" valign="top"><a id="afd02e8969d6e05ea36e5531014d72084" name="afd02e8969d6e05ea36e5531014d72084"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>perturbCoords</b> (const greal)</td></tr>
<tr class="memdesc:afd02e8969d6e05ea36e5531014d72084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each atom is moved in a random direction by a vector of the passed size. <br /></td></tr>
<tr class="separator:afd02e8969d6e05ea36e5531014d72084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f2e80a4b176ffa3451998b3df917530" id="r_a6f2e80a4b176ffa3451998b3df917530"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classloos_1_1_coord.html">GCoord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f2e80a4b176ffa3451998b3df917530">principalAxes</a> (void) const</td></tr>
<tr class="memdesc:a6f2e80a4b176ffa3451998b3df917530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the principal axes of a group.  <br /></td></tr>
<tr class="separator:a6f2e80a4b176ffa3451998b3df917530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e3bf02b3646d2ae45a15cbbe088678" id="r_a74e3bf02b3646d2ae45a15cbbe088678"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74e3bf02b3646d2ae45a15cbbe088678">principalAxesOrder</a> (void) const</td></tr>
<tr class="memdesc:a74e3bf02b3646d2ae45a15cbbe088678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes order parameter based on principalAxes.  <br /></td></tr>
<tr class="separator:a74e3bf02b3646d2ae45a15cbbe088678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b6aa6394b1759104d8cadb2518061bf" id="r_a8b6aa6394b1759104d8cadb2518061bf"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classloos_1_1_coord.html">GCoord</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b6aa6394b1759104d8cadb2518061bf">momentsOfInertia</a> (void) const</td></tr>
<tr class="memdesc:a8b6aa6394b1759104d8cadb2518061bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the moments of inertia for a group.  <br /></td></tr>
<tr class="separator:a8b6aa6394b1759104d8cadb2518061bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc303bb0118c356d6878f75855742733" id="r_afc303bb0118c356d6878f75855742733"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classloos_1_1_matrix44.html">GMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc303bb0118c356d6878f75855742733">superposition</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;)</td></tr>
<tr class="memdesc:afc303bb0118c356d6878f75855742733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the transformation matrix for superposition of groups.  <br /></td></tr>
<tr class="separator:afc303bb0118c356d6878f75855742733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d1966c971d7730391d417bcdfd1486e" id="r_a9d1966c971d7730391d417bcdfd1486e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classloos_1_1_matrix44.html">GMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d1966c971d7730391d417bcdfd1486e">alignOnto</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;)</td></tr>
<tr class="memdesc:a9d1966c971d7730391d417bcdfd1486e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Superimposes the current group onto the passed group.  <br /></td></tr>
<tr class="separator:a9d1966c971d7730391d417bcdfd1486e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e75db558cb8fe73ca17da92ba9cb66f" id="r_a0e75db558cb8fe73ca17da92ba9cb66f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e75db558cb8fe73ca17da92ba9cb66f">orientAlong</a> (const <a class="el" href="classloos_1_1_coord.html">GCoord</a> &amp;)</td></tr>
<tr class="memdesc:a0e75db558cb8fe73ca17da92ba9cb66f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orient the principal axis of this group along the supplied vector.  <br /></td></tr>
<tr class="separator:a0e75db558cb8fe73ca17da92ba9cb66f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f01a0fa6b0ccf7ae7400b2530f85051" id="r_a6f01a0fa6b0ccf7ae7400b2530f85051"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f01a0fa6b0ccf7ae7400b2530f85051">setCoords</a> (double *<a class="el" href="classloos_1_1_math_1_1_matrix.html">seq</a>, int m, int n)</td></tr>
<tr class="separator:a6f01a0fa6b0ccf7ae7400b2530f85051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605b30aef2f4da808eb92ec0ae0fe9f2" id="r_a605b30aef2f4da808eb92ec0ae0fe9f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a605b30aef2f4da808eb92ec0ae0fe9f2">getCoords</a> (double **<a class="el" href="classloos_1_1_math_1_1_matrix.html">outseq</a>, int *m, int *n)</td></tr>
<tr class="separator:a605b30aef2f4da808eb92ec0ae0fe9f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f782f69c1788b4d7f83efcd5dafb6cd" id="r_a3f782f69c1788b4d7f83efcd5dafb6cd"><td class="memItemLeft" align="right" valign="top"><a id="a3f782f69c1788b4d7f83efcd5dafb6cd" name="a3f782f69c1788b4d7f83efcd5dafb6cd"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>coordsAsVector</b> () const</td></tr>
<tr class="separator:a3f782f69c1788b4d7f83efcd5dafb6cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67856c19aa37badca3173a434bc4ee30" id="r_a67856c19aa37badca3173a434bc4ee30"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67856c19aa37badca3173a434bc4ee30">packingScore</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;other, const <a class="el" href="classloos_1_1_coord.html">GCoord</a> &amp;box, bool norm) const</td></tr>
<tr class="separator:a67856c19aa37badca3173a434bc4ee30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad07e54151a5ebe831491bc84debf5b3e" id="r_ad07e54151a5ebe831491bc84debf5b3e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad07e54151a5ebe831491bc84debf5b3e">logisticContact</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;<a class="el" href="classloos_1_1_math_1_1_matrix.html">group</a>, double <a class="el" href="#a4189af9a4ace2bfc2921bb1d57c044d9">radius</a>, int sigma, const <a class="el" href="classloos_1_1_coord.html">GCoord</a> &amp;box) const</td></tr>
<tr class="separator:ad07e54151a5ebe831491bc84debf5b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff9ce04f6f9be8ed10974c5c49563e5" id="r_a1ff9ce04f6f9be8ed10974c5c49563e5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ff9ce04f6f9be8ed10974c5c49563e5">logisticContact2D</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;<a class="el" href="classloos_1_1_math_1_1_matrix.html">group</a>, double <a class="el" href="#a4189af9a4ace2bfc2921bb1d57c044d9">radius</a>, int sigma, const <a class="el" href="classloos_1_1_coord.html">GCoord</a> &amp;box) const</td></tr>
<tr class="separator:a1ff9ce04f6f9be8ed10974c5c49563e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a51952741fd2ba1e9afa052cdd4dcb" id="r_a18a51952741fd2ba1e9afa052cdd4dcb"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18a51952741fd2ba1e9afa052cdd4dcb">hardContact</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;<a class="el" href="classloos_1_1_math_1_1_matrix.html">group</a>, double <a class="el" href="#a4189af9a4ace2bfc2921bb1d57c044d9">radius</a>, const <a class="el" href="classloos_1_1_coord.html">GCoord</a> &amp;box) const</td></tr>
<tr class="separator:a18a51952741fd2ba1e9afa052cdd4dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c03d43a9ad6c0b088c44393246b5c3" id="r_a40c03d43a9ad6c0b088c44393246b5c3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40c03d43a9ad6c0b088c44393246b5c3">hardContact2D</a> (const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;<a class="el" href="classloos_1_1_math_1_1_matrix.html">group</a>, double <a class="el" href="#a4189af9a4ace2bfc2921bb1d57c044d9">radius</a>, const <a class="el" href="classloos_1_1_coord.html">GCoord</a> &amp;box) const</td></tr>
<tr class="separator:a40c03d43a9ad6c0b088c44393246b5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8849c3ea931587dfa316b5431f18300" id="r_ab8849c3ea931587dfa316b5431f18300"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8849c3ea931587dfa316b5431f18300">scattering</a> (const double <a class="el" href="classloos_1_1_math_1_1_matrix.html">qmin</a>, const double <a class="el" href="classloos_1_1_math_1_1_matrix.html">max</a>, const uint <a class="el" href="classloos_1_1_math_1_1_matrix.html">numValues</a>, <a class="el" href="classloos_1_1_form_factor_set.html">loos::FormFactorSet</a> &amp;formFactors)</td></tr>
<tr class="separator:ab8849c3ea931587dfa316b5431f18300"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a33c54758a5fbee379f6f3fa442c71044" id="r_a33c54758a5fbee379f6f3fa442c71044"><td class="memItemLeft" align="right" valign="top"><a id="a33c54758a5fbee379f6f3fa442c71044" name="a33c54758a5fbee379f6f3fa442c71044"></a>
<a class="el" href="classloos_1_1_math_1_1_matrix.html">static</a> const double&#160;</td><td class="memItemRight" valign="bottom"><b>superposition_zero_singular_value</b> = 1<a class="el" href="classloos_1_1_math_1_1_matrix.html">e</a>-10</td></tr>
<tr class="separator:a33c54758a5fbee379f6f3fa442c71044"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ae879f425747b04dd2254770990cb5bea" id="r_ae879f425747b04dd2254770990cb5bea"><td class="memItemLeft" align="right" valign="top"><a id="ae879f425747b04dd2254770990cb5bea" name="ae879f425747b04dd2254770990cb5bea"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setGroupConnectivity</b> ()</td></tr>
<tr class="separator:ae879f425747b04dd2254770990cb5bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aa568698d3ece67936eacda77df4c5f84" id="r_aa568698d3ece67936eacda77df4c5f84"><td class="memItemLeft" align="right" valign="top"><a id="aa568698d3ece67936eacda77df4c5f84" name="aa568698d3ece67936eacda77df4c5f84"></a>
std::vector&lt; pAtom &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>atoms</b></td></tr>
<tr class="separator:aa568698d3ece67936eacda77df4c5f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1509b8935261a029a9a19698cfd47a40" id="r_a1509b8935261a029a9a19698cfd47a40"><td class="memItemLeft" align="right" valign="top"><a id="a1509b8935261a029a9a19698cfd47a40" name="a1509b8935261a029a9a19698cfd47a40"></a>
<a class="el" href="classloos_1_1_shared_periodic_box.html">loos::SharedPeriodicBox</a>&#160;</td><td class="memItemRight" valign="bottom"><b>box</b></td></tr>
<tr class="separator:a1509b8935261a029a9a19698cfd47a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a3721e6e76de8ac5e013317c38d30fe75" id="r_a3721e6e76de8ac5e013317c38d30fe75"><td class="memItemLeft" align="right" valign="top"><a id="a3721e6e76de8ac5e013317c38d30fe75" name="a3721e6e76de8ac5e013317c38d30fe75"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;grp)</td></tr>
<tr class="memdesc:a3721e6e76de8ac5e013317c38d30fe75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the group in pseudo-XML format... <br /></td></tr>
<tr class="separator:a3721e6e76de8ac5e013317c38d30fe75"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class for handling groups of Atoms (pAtoms, actually) </p>
<p>This class contains a collection of shared pointers to Atoms (i.e. pAtoms). Copying an <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually)">AtomicGroup</a> is a light-copy. You can, however, perform a deep copy by using the <a class="el" href="#a0dcd01a7efbe31915470ff25dd337d3f" title="Creates a deep copy of this group.">AtomicGroup::copy()</a> method. Note that atomid's are assumed to be unique for any given <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually)">AtomicGroup</a>.</p>
<p>Valid operators are '+' and '+=' and can combine either <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually)">AtomicGroup</a> objects or pAtom objects.</p>
<p>AtomicGroups also support periodic boundary conditions via the <a class="el" href="#a5b6b8769575bff01cf96bd283a32d029" title="Fetch the periodic boundary conditions.">periodicBox()</a> method. If a box has been set, then <a class="el" href="#a1aed84043a9af6ec6217b7c0b6b041df" title="Test whether or not periodic boundary conditions are set.">isPeriodic()</a> will return true. The periodic box is shared between the parent group and all derived groups. <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually)">AtomicGroup</a> copies have non-shared periodic boxes... </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a125a4b144bc5457366ae204e8f98f446" name="a125a4b144bc5457366ae204e8f98f446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a125a4b144bc5457366ae204e8f98f446">&#9670;&#160;</a></span>AtomicGroup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">loos::AtomicGroup::AtomicGroup </td>
          <td>(</td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually)">AtomicGroup</a> with <em>n</em> un-initialized atoms. </p>
<p>The atoms will all have ascending atomid's beginning with 1, but otherwise no other properties will be set. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9d1966c971d7730391d417bcdfd1486e" name="a9d1966c971d7730391d417bcdfd1486e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d1966c971d7730391d417bcdfd1486e">&#9670;&#160;</a></span>alignOnto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_matrix44.html">GMatrix</a> loos::AtomicGroup::alignOnto </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>grp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Superimposes the current group onto the passed group. </p>
<p>Calls superposition to calculate the transformation matrix to superimpose the current group onto the passed one, then applies the transformation to the current group's coordinates. </p>

</div>
</div>
<a id="a300ee7d7bb26e246c1cd78829191a4fd" name="a300ee7d7bb26e246c1cd78829191a4fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a300ee7d7bb26e246c1cd78829191a4fd">&#9670;&#160;</a></span>apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T loos::AtomicGroup::apply </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>func</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a functor or a function to each atom in the group. </p>
<p><a class="el" href="#a300ee7d7bb26e246c1cd78829191a4fd" title="Apply a functor or a function to each atom in the group.">apply()</a> let's you apply a functor or a function pointer to each atom in the group. The functor is passed a pAtom. The functor object is also returned (in case it retained state). For example, the following code snippet shows how to calculate the centroid of a group using apply and a functor... </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_class" href="classloos_1_1_math_1_1_matrix.html">Functor</a> {</div>
<div class="line"><a class="code hl_class" href="classloos_1_1_math_1_1_matrix.html">Functor</a>() : <a class="code hl_class" href="classloos_1_1_math_1_1_matrix.html">C</a>(<a class="code hl_class" href="classloos_1_1_coord.html">GCoord</a>(0,0,0)), n(0) { }</div>
<div class="line"><span class="keywordtype">void</span> operator()(pAtom&amp; p) { <a class="code hl_class" href="classloos_1_1_math_1_1_matrix.html">C</a> += p-&gt;coords(); ++n; }</div>
<div class="line">GCoord center(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span>(C/n); }</div>
<div class="line"> </div>
<div class="line">GCoord C;</div>
<div class="line"><span class="keywordtype">int</span> n;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classloos_1_1_math_1_1_matrix.html">Functor</a> f = group.apply(<a class="code hl_class" href="classloos_1_1_math_1_1_matrix.html">Functor</a>());</div>
<div class="line">GCoord <a class="code hl_function" href="#a0a83f0a04b7b4bf45291c186b29859d1">centroid</a> = f.center();</div>
<div class="ttc" id="aclassloos_1_1_atomic_group_html_a0a83f0a04b7b4bf45291c186b29859d1"><div class="ttname"><a href="#a0a83f0a04b7b4bf45291c186b29859d1">loos::AtomicGroup::centroid</a></div><div class="ttdeci">GCoord centroid(void) const</div><div class="ttdoc">Centroid of atoms (ignores mass, operates in group coordinates)</div><div class="ttdef"><b>Definition</b> AG_numerical.cpp:83</div></div>
<div class="ttc" id="aclassloos_1_1_coord_html"><div class="ttname"><a href="classloos_1_1_coord.html">loos::Coord&lt; double &gt;</a></div></div>
<div class="ttc" id="aclassloos_1_1_math_1_1_matrix_html"><div class="ttname"><a href="classloos_1_1_math_1_1_matrix.html">loos::Math::Matrix</a></div><div class="ttdoc">Simple matrix template class using policy classes to determine behavior.</div><div class="ttdef"><b>Definition</b> MatrixImpl.hpp:148</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a6c50256c66c58e818df2090b1cdce05c" name="a6c50256c66c58e818df2090b1cdce05c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c50256c66c58e818df2090b1cdce05c">&#9670;&#160;</a></span>atomOrderMapFrom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint &gt; loos::AtomicGroup::atomOrderMapFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map the order of atoms in <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually)">AtomicGroup</a> g into the current group. </p>
<p>Note that the order is only checked within a residue. The residues must appear in the same order between the two groups. This addresses edge issues such as when psfgen reorders the atoms within a residue. The map is an index into the <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually)">AtomicGroup</a> g that puts g into the same order as the current group. </p>

</div>
</div>
<a id="a159dd8fcf36911e4a3f95f701bb9cf9d" name="a159dd8fcf36911e4a3f95f701bb9cf9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a159dd8fcf36911e4a3f95f701bb9cf9d">&#9670;&#160;</a></span>boundingBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classloos_1_1_coord.html">GCoord</a> &gt; loos::AtomicGroup::boundingBox </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bounding box for the group... </p>
<p>Returns a vector containing 2 GCoords, one containing (minx, miny, minz) and the other (maxx, maxy, maxz) </p>

</div>
</div>
<a id="a429f96e9a94724ec68796f4c856f76b5" name="a429f96e9a94724ec68796f4c856f76b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a429f96e9a94724ec68796f4c856f76b5">&#9670;&#160;</a></span>centerAtOrigin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_coord.html">GCoord</a> loos::AtomicGroup::centerAtOrigin </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translates the group so that the centroid is at the origin. </p>
<p>Returns the old centroid of the group </p>

</div>
</div>
<a id="afe2abaa9ad389ffb170b72defb79056b" name="afe2abaa9ad389ffb170b72defb79056b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe2abaa9ad389ffb170b72defb79056b">&#9670;&#160;</a></span>centrifyByMolecule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> loos::AtomicGroup::centrifyByMolecule </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace a group with the center of masses of contained molecules. </p>
<p>The <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually)">AtomicGroup</a> is split into molecules. A new group is constructed where each atom is the center of mass of one molecule. The atom metadata is taken from the first atom of the associated molecule, but with the atom name "CEN". </p>

</div>
</div>
<a id="a10a35c891ecf43b59745991592755ba0" name="a10a35c891ecf43b59745991592755ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10a35c891ecf43b59745991592755ba0">&#9670;&#160;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> * loos::AtomicGroup::clone </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a lightweight clone of this group (for polymorphism) </p>
<p>Despite the name, this is meant for polymorphic use. It is <em>not</em> a deep copy. If you don't understand what any of this means, then you almost certainly want to be using the <a class="el" href="#a0dcd01a7efbe31915470ff25dd337d3f" title="Creates a deep copy of this group.">copy()</a> method instead. </p>

<p>Reimplemented in <a class="el" href="classloos_1_1_amber.html#a711cf84d02091b41a803be8454ed97f3">loos::Amber</a>, <a class="el" href="classloos_1_1_c_h_a_r_m_m.html#a7b379f07b43cd58148b2ce7c4baf5832">loos::CHARMM</a>, <a class="el" href="classloos_1_1_m_d_traj.html#ad763709117a73bf72ad990a0c96a9d09">loos::MDTraj</a>, <a class="el" href="classloos_1_1_m_m_c_i_f.html#a18e354a3e94c83d8d063b89d476eb634">loos::MMCIF</a>, <a class="el" href="classloos_1_1_p_d_b.html#a8264abebb018eb49f64f165b65896449">loos::PDB</a>, <a class="el" href="classloos_1_1_p_s_f.html#a830bc776e1a58c3893610a4f806429cb">loos::PSF</a>, and <a class="el" href="classloos_1_1_tinker_x_y_z.html#a900b3f40954185abdd1ed56f59384ed3">loos::TinkerXYZ</a>.</p>

</div>
</div>
<a id="afd13acd542df91d1190854f6b270556d" name="afd13acd542df91d1190854f6b270556d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd13acd542df91d1190854f6b270556d">&#9670;&#160;</a></span>contactWith() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool loos::AtomicGroup::contactWith </td>
          <td>(</td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>dist</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>grp</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_coord.html">GCoord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>box</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint</td>          <td class="paramname"><span class="paramname"><em>min</em><span class="paramdefsep"> = </span><span class="paramdefval">1</span></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if any atom of current group is within <em>dist</em> angstroms of <em>grp</em>. </p>
<p><em>min</em> is the minimum number of pair-wise contacts required to be considered in contact </p>

</div>
</div>
<a id="abff9fcfd9ddc21f9c22f3f37757b0c4e" name="abff9fcfd9ddc21f9c22f3f37757b0c4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abff9fcfd9ddc21f9c22f3f37757b0c4e">&#9670;&#160;</a></span>contactWith() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool loos::AtomicGroup::contactWith </td>
          <td>(</td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>dist</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>grp</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint</td>          <td class="paramname"><span class="paramname"><em>min</em><span class="paramdefsep"> = </span><span class="paramdefval">1</span></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if any atom of current group is within <em>dist</em> angstroms of <em>grp</em>. </p>
<p><em>min</em> is the minimum number of pair-wise contacts required to be considered in contact </p>

</div>
</div>
<a id="a1608898640569fc6633ae6e851695976" name="a1608898640569fc6633ae6e851695976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1608898640569fc6633ae6e851695976">&#9670;&#160;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> EqualsOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool loos::AtomicGroup::contains </td>
          <td>(</td>
          <td class="paramtype">const pAtom &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EqualsOp &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if a pAtom is contained in this group using the EqualsOp atom-equality policy. </p>
<p>The problem with determining containment/intersection/etc is how to define when two atoms are equal... This is done by specifying a comparison functor (the EqualsOp) as a policy. There are two comparison policies currently in LOOS: <a class="el" href="structloos_1_1_atom_equals.html" title="Compares two atoms based solely on name, id, resid, resname, and segid.">AtomEquals</a> and <a class="el" href="structloos_1_1_atom_coords_equals.html" title="Compares two atoms based on name, id, resid, resname, segid, and coords.">AtomCoordsEquals</a>. The default behavior is to use <a class="el" href="structloos_1_1_atom_equals.html" title="Compares two atoms based solely on name, id, resid, resname, and segid.">AtomEquals</a> which only compares a subset of the available <a class="el" href="classloos_1_1_atom.html" title="Basic Atom class for handling atom properties.">Atom</a> metadata. You can specify the more restrictive policy (or an user-defined policy) like: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> b = <a class="code hl_class" href="classloos_1_1_math_1_1_matrix.html">group</a>.contains(<a class="code hl_class" href="classloos_1_1_math_1_1_matrix.html">an_atom</a>, <a class="code hl_struct" href="structloos_1_1_atom_coords_equals.html">loos::AtomCoordsEquals</a>());</div>
<div class="ttc" id="astructloos_1_1_atom_coords_equals_html"><div class="ttname"><a href="structloos_1_1_atom_coords_equals.html">loos::AtomCoordsEquals</a></div><div class="ttdoc">Compares two atoms based on name, id, resid, resname, segid, and coords.</div><div class="ttdef"><b>Definition</b> Atom.hpp:294</div></div>
</div><!-- fragment --><p>Or as another example, comparing only residue numbers... </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_class" href="classloos_1_1_math_1_1_matrix.html">ResidEquals</a> {</div>
<div class="line">  <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> pAtom&amp; a, <span class="keyword">const</span> pAtom&amp; b) { <span class="keywordflow">return</span>(a.resid() == b.resid()); }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> b = group.contains(<a class="code hl_class" href="classloos_1_1_math_1_1_matrix.html">an_atom</a>, <a class="code hl_class" href="classloos_1_1_math_1_1_matrix.html">ResidEquals</a>());</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a0dcd01a7efbe31915470ff25dd337d3f" name="a0dcd01a7efbe31915470ff25dd337d3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dcd01a7efbe31915470ff25dd337d3f">&#9670;&#160;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> loos::AtomicGroup::copy </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a deep copy of this group. </p>
<p>This creates a non-polymorphic deep copy of an <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually)">AtomicGroup</a>. The additional catch is that it may end up involving extra data-movement as the copy is constructed and then copied back out to wherever you're putting it. </p>

</div>
</div>
<a id="a922415f440fece32f23da2103cdc8d0d" name="a922415f440fece32f23da2103cdc8d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a922415f440fece32f23da2103cdc8d0d">&#9670;&#160;</a></span>copyCoordinatesFrom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void loos::AtomicGroup::copyCoordinatesFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint</td>          <td class="paramname"><span class="paramname"><em>offset</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint</td>          <td class="paramname"><span class="paramname"><em>length</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy coordinates from g into current group. </p>
<p>The offset is relative to the start of the current group and length is the number of coordinates to copy. If length + offset is greater than the number of atoms in the current group, then the excess coordinates will not be copied.</p>
<p>If length is 0, then all coordinates in g will be copied.</p>
<p>It is assumed that the atoms in g are in the appropriate order relative to the current group for the copy to make sense. </p>

</div>
</div>
<a id="a5a3a1163fdcd8234a4e78dda2fb9bf0e" name="a5a3a1163fdcd8234a4e78dda2fb9bf0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a3a1163fdcd8234a4e78dda2fb9bf0e">&#9670;&#160;</a></span>copyMappedCoordinatesFrom() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void loos::AtomicGroup::copyMappedCoordinatesFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the coordinates from the group mapping the atom order. </p>
<p>See AtomicGroup::atomOrderFrom(const AtomicGroup&amp; g) for more information</p>
<p>If you know that the atoms are in the same order in both groups, then <a class="el" href="#a922415f440fece32f23da2103cdc8d0d" title="Copy coordinates from g into current group.">AtomicGroup::copyCoordinatesFrom()</a> will be faster... </p>

</div>
</div>
<a id="a3fd03b1c9bfad1e983b3c616350304cf" name="a3fd03b1c9bfad1e983b3c616350304cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fd03b1c9bfad1e983b3c616350304cf">&#9670;&#160;</a></span>copyMappedCoordinatesFrom() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void loos::AtomicGroup::copyMappedCoordinatesFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a mapping of atom order, copy the coordinates into the current group. </p>
<p>See <a class="el" href="#a6c50256c66c58e818df2090b1cdce05c" title="Map the order of atoms in AtomicGroup g into the current group.">AtomicGroup::atomOrderMapFrom(const AtomicGroup&amp; g)</a> for more information</p>
<p>If you know that the atoms are in the same order in both groups, then <a class="el" href="#a922415f440fece32f23da2103cdc8d0d" title="Copy coordinates from g into current group.">AtomicGroup::copyCoordinatesFrom()</a> will be faster... </p>

</div>
</div>
<a id="a4c5a37ae808c139a54eb8049601ffc85" name="a4c5a37ae808c139a54eb8049601ffc85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c5a37ae808c139a54eb8049601ffc85">&#9670;&#160;</a></span>copyVelocitiesWithIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void loos::AtomicGroup::copyVelocitiesWithIndex </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classloos_1_1_coord.html">GCoord</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>velocities</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy velocities from a vector of GCoords using the atom index as an index into the vector. </p>
<p>This can be used to update a group's velocities if they come from a separate trajectory... </p><div class="fragment"><div class="line">pTraj <a class="code hl_class" href="classloos_1_1_math_1_1_matrix.html">trajcrds</a> = createTrajectory(<span class="stringliteral">&#39;foo.dcd&#39;</span>, model);</div>
<div class="line">pTraj <a class="code hl_class" href="classloos_1_1_math_1_1_matrix.html">trajvels</a> = createTrajectory(<span class="stringliteral">&#39;foo-velocities.dcd&#39;</span>, model);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">while</span> (<a class="code hl_class" href="classloos_1_1_math_1_1_matrix.html">trajcrds</a>-&gt;readFrame()) {</div>
<div class="line">   <a class="code hl_class" href="classloos_1_1_math_1_1_matrix.html">trajcrds</a>-&gt;updateGroupCoords(model);</div>
<div class="line"> </div>
<div class="line">   <a class="code hl_class" href="classloos_1_1_math_1_1_matrix.html">trajvels</a>-&gt;readFrame();</div>
<div class="line">   model.copyVelocitiesWithIndex(<a class="code hl_class" href="classloos_1_1_math_1_1_matrix.html">trajvels</a>-&gt;coords());</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="afbf2ee4a474c487db2dab7651ddb5204" name="afbf2ee4a474c487db2dab7651ddb5204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbf2ee4a474c487db2dab7651ddb5204">&#9670;&#160;</a></span>deduceAtomicNumberFromMass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint loos::AtomicGroup::deduceAtomicNumberFromMass </td>
          <td>(</td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>tol</em><span class="paramdefsep"> = </span><span class="paramdefval">0.1</span></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduce atomic number from mass (if present), returning number of atoms assigned. </p>
<p>If an atom has a mass, then this is used to look up it's atomic number. Note that LOOS only has the first 96 elements in its tables. If a mass is not found in the LOOS table, then the atomic number is not modified (or set), otherwise any existing atomic number is overwritten. </p>

</div>
</div>
<a id="a27e479d941d1ef160286bedecde57330" name="a27e479d941d1ef160286bedecde57330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27e479d941d1ef160286bedecde57330">&#9670;&#160;</a></span>differenceVectors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classloos_1_1_coord.html">GCoord</a> &gt; loos::AtomicGroup::differenceVectors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute difference vectors between two AtomicGroups. </p>
<p>Does not align the coordinates first </p>

</div>
</div>
<a id="a27b5b12845449dddc4df4cc16fa89b30" name="a27b5b12845449dddc4df4cc16fa89b30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27b5b12845449dddc4df4cc16fa89b30">&#9670;&#160;</a></span>findBonds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void loos::AtomicGroup::findBonds </td>
          <td>(</td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>dist</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_coord.html">GCoord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>box</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Distance-based search for bonds. </p>
<p>Searches for bonds within an <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually)">AtomicGroup</a> based on distance. does NOT clear the existing bond list prior to building new bonds. The default distance cutoff is <a class="el" href="classloos_1_1_math_1_1_matrix.html#a41fd964667734df58317f06f951dd513" title="Unitialized matrix.">1.65</a>. If a box (GCoord) is passed, then periodicity is taken into consideration. </p>

</div>
</div>
<a id="a3885f492e4f67f184ce4f48fe1e5ecdc" name="a3885f492e4f67f184ce4f48fe1e5ecdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3885f492e4f67f184ce4f48fe1e5ecdc">&#9670;&#160;</a></span>findById()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pAtom loos::AtomicGroup::findById </td>
          <td>(</td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>id</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a contained atom by its atomid. </p>
<p>The default behavior is to assume that the atoms in the <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually)">AtomicGroup</a> are not in order of increasing atomid and to therefore use a linear search. If the atoms are sorted (<a class="el" href="#ae4df4c4e55665b8c6f8d09fc467fc35c" title="Sort based on atomid.">AtomicGroup::sort()</a>), then the more efficient binary search will be used. </p>

</div>
</div>
<a id="a605b30aef2f4da808eb92ec0ae0fe9f2" name="a605b30aef2f4da808eb92ec0ae0fe9f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a605b30aef2f4da808eb92ec0ae0fe9f2">&#9670;&#160;</a></span>getCoords()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void loos::AtomicGroup::getCoords </td>
          <td>(</td>
          <td class="paramtype">double **</td>          <td class="paramname"><span class="paramname"><em>outseq</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>m</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is meant for Numpy/swig use. It will store the current model's coordinates into a newly allocated array (using malloc). The caller is expected to manage the memory. </p>

</div>
</div>
<a id="a0b5f36f01919f6b54fa410e956c02816" name="a0b5f36f01919f6b54fa410e956c02816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b5f36f01919f6b54fa410e956c02816">&#9670;&#160;</a></span>getResidue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> loos::AtomicGroup::getResidue </td>
          <td>(</td>
          <td class="paramtype">pAtom</td>          <td class="paramname"><span class="paramname"><em>res</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given an <a class="el" href="classloos_1_1_atom.html" title="Basic Atom class for handling atom properties.">Atom</a>, return a group of all the atoms contained by its containing residue </p>

</div>
</div>
<a id="a94c75544e38f86bd7d34d7f1a447b0df" name="a94c75544e38f86bd7d34d7f1a447b0df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94c75544e38f86bd7d34d7f1a447b0df">&#9670;&#160;</a></span>getTransformedCoords()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classloos_1_1_coord.html">GCoord</a> &gt; loos::AtomicGroup::getTransformedCoords </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_x_form.html">XForm</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>M</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of coordinates transformed by the passed <a class="el" href="classloos_1_1_x_form.html" title="Matrix class for handling coordinate transforms...">XForm</a>. </p>
<p>Does not alter the group's coordinates... </p>

</div>
</div>
<a id="a8fb24aeea1945cf42f234e8597aca062" name="a8fb24aeea1945cf42f234e8597aca062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fb24aeea1945cf42f234e8597aca062">&#9670;&#160;</a></span>groupFromID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> loos::AtomicGroup::groupFromID </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>id_list</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new group from a vector of atomids. </p>
<p>Note: when calling this, you'll want to make sure you use the outermost group (eg the psf or pdb you used to create things, rather than using a subselection, unless you're sure the subsection contains these atoms as well. The main use of this routine is to create a group of atoms bound to another atom.</p>
<p>Any missing atoms are ignored... This is in contrast with the previous behavior where missing atoms would throw an exception </p>

</div>
</div>
<a id="a18a51952741fd2ba1e9afa052cdd4dcb" name="a18a51952741fd2ba1e9afa052cdd4dcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18a51952741fd2ba1e9afa052cdd4dcb">&#9670;&#160;</a></span>hardContact()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double loos::AtomicGroup::hardContact </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>group</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>radius</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_coord.html">GCoord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>box</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute contact value of another AG with respect to the centroid of a given AG, using a hard step function S = 1; iff dist &lt;= radius; else 0 </p>

</div>
</div>
<a id="a40c03d43a9ad6c0b088c44393246b5c3" name="a40c03d43a9ad6c0b088c44393246b5c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40c03d43a9ad6c0b088c44393246b5c3">&#9670;&#160;</a></span>hardContact2D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double loos::AtomicGroup::hardContact2D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>group</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>radius</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_coord.html">GCoord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>box</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute contact value of another AG with respect to the centroid of a given AG, using a hard step function S = 1; iff dist &lt;= radius; else 0 </p>

</div>
</div>
<a id="a872a5b02eca7320f51181b5a8385e6e5" name="a872a5b02eca7320f51181b5a8385e6e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a872a5b02eca7320f51181b5a8385e6e5">&#9670;&#160;</a></span>intersect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> EqualsOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> loos::AtomicGroup::intersect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EqualsOp &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the intersection of two groups using the EqualsOp atom-equality policy. </p>
<p>See AtomicGroup::contains(const pAtom&amp;, const EqualsOp&amp;) for more details </p>

</div>
</div>
<a id="abb7901950b11a6f06080ee338bd53b72" name="abb7901950b11a6f06080ee338bd53b72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb7901950b11a6f06080ee338bd53b72">&#9670;&#160;</a></span>kineticEnergy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">greal loos::AtomicGroup::kineticEnergy </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute kinetic energy of group. </p>
<p>Assumes mass and velocity have been set. Output units are kcal/mol </p>

</div>
</div>
<a id="ad07e54151a5ebe831491bc84debf5b3e" name="ad07e54151a5ebe831491bc84debf5b3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad07e54151a5ebe831491bc84debf5b3e">&#9670;&#160;</a></span>logisticContact()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double loos::AtomicGroup::logisticContact </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>group</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>radius</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>sigma</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_coord.html">GCoord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>box</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the degree of contact between the centroid of this AG and the centroid of another AG, using a smooth logistic function S = 1/(1 + dist/radius)**sigma </p>

</div>
</div>
<a id="a1ff9ce04f6f9be8ed10974c5c49563e5" name="a1ff9ce04f6f9be8ed10974c5c49563e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ff9ce04f6f9be8ed10974c5c49563e5">&#9670;&#160;</a></span>logisticContact2D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double loos::AtomicGroup::logisticContact2D </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>group</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>radius</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>sigma</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_coord.html">GCoord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>box</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the number of contacts between the centroid of this AG and the centroid of another AG, using a smooth logistic function S = 1/(1 + dist/radius)**sigma </p>

</div>
</div>
<a id="a565774cc283d8e5e65fc486330c744f9" name="a565774cc283d8e5e65fc486330c744f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a565774cc283d8e5e65fc486330c744f9">&#9670;&#160;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classloos_1_1_math_1_1_matrix.html">class</a> EqualsOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> loos::AtomicGroup::merge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EqualsOp &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Union of two groups using the specified atom-equality policy. </p>
<p>Note that the periodic box of the current group is unchanged by this operation </p>

</div>
</div>
<a id="a4b136bf681b267e113c35a6651cbfe51" name="a4b136bf681b267e113c35a6651cbfe51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b136bf681b267e113c35a6651cbfe51">&#9670;&#160;</a></span>mergeImage() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void loos::AtomicGroup::mergeImage </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a group that's split across a periodic boundary and reimages it so it's all together, using the first atom in the <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually)">AtomicGroup</a> as the reference. </p>
<p>Does the same as the other mergeImage, only using the first atom in the <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually)">AtomicGroup</a> as the reference atom. </p>

</div>
</div>
<a id="ab8224e853282a81e55ca83fc8594cd80" name="ab8224e853282a81e55ca83fc8594cd80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8224e853282a81e55ca83fc8594cd80">&#9670;&#160;</a></span>mergeImage() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void loos::AtomicGroup::mergeImage </td>
          <td>(</td>
          <td class="paramtype">pAtom &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a group that's split across a periodic boundary and reimages it so it's all together. </p>
<p>Works by translating the system so one atom is in the center of the box, reimaging by atom (so now the group is all in the middle of the box), and then translating back.</p>
<p>If you don't want to give it a reference atom, call the version that takes no argument; it uses the first atom in the <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually)">AtomicGroup</a>. </p>

</div>
</div>
<a id="a8b6aa6394b1759104d8cadb2518061bf" name="a8b6aa6394b1759104d8cadb2518061bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b6aa6394b1759104d8cadb2518061bf">&#9670;&#160;</a></span>momentsOfInertia()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classloos_1_1_coord.html">GCoord</a> &gt; loos::AtomicGroup::momentsOfInertia </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the moments of inertia for a group. </p>
<p>Calculates the principal moments and principal axes (from the moment of inertia). This is distinct from the <a class="el" href="#a6f2e80a4b176ffa3451998b3df917530" title="Compute the principal axes of a group.">principalAxes()</a> function which calculates the distribution of points about the centroid. </p>

</div>
</div>
<a id="a838252229a0bae82a0c6184c4a7638ba" name="a838252229a0bae82a0c6184c4a7638ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a838252229a0bae82a0c6184c4a7638ba">&#9670;&#160;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool loos::AtomicGroup::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equality test for two groups. </p>
<p>The test for equality is based on whether or not the contained atom pointers are the same. This operator will also force both sides of the equation to be sorted. </p>

</div>
</div>
<a id="ac96574981311e2631eeeafdce28dfce3" name="ac96574981311e2631eeeafdce28dfce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac96574981311e2631eeeafdce28dfce3">&#9670;&#160;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool loos::AtomicGroup::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equality test for const groups. </p>
<p>Similar to the non-const version, but it will sort <em>copies</em> of the atom lists if they are not already sorted... </p>

</div>
</div>
<a id="a0e75db558cb8fe73ca17da92ba9cb66f" name="a0e75db558cb8fe73ca17da92ba9cb66f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e75db558cb8fe73ca17da92ba9cb66f">&#9670;&#160;</a></span>orientAlong()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void loos::AtomicGroup::orientAlong </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_coord.html">GCoord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vec</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Orient the principal axis of this group along the supplied vector. </p>
<p>The supplied vector does not need to be normalized. </p>

</div>
</div>
<a id="a67856c19aa37badca3173a434bc4ee30" name="a67856c19aa37badca3173a434bc4ee30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67856c19aa37badca3173a434bc4ee30">&#9670;&#160;</a></span>packingScore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double loos::AtomicGroup::packingScore </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_coord.html">GCoord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>box</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>norm</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classloos_1_1_math_1_1_matrix.html">false</a></span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The packing score is the sum of 1/r^6 over all pairs of atoms, respecting periodicity. Quantity first defined in Grossfield, A., et al, Proc. Nat. Acad. Sci. USA, 2006, 103, 4888-4893 </p>

</div>
</div>
<a id="a6f2e80a4b176ffa3451998b3df917530" name="a6f2e80a4b176ffa3451998b3df917530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f2e80a4b176ffa3451998b3df917530">&#9670;&#160;</a></span>principalAxes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classloos_1_1_coord.html">GCoord</a> &gt; loos::AtomicGroup::principalAxes </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the principal axes of a group. </p>
<p>Calculates the eigendecomposition of AA' where A is column-wise concatenation of coordinates from all atoms in the group. The mean coordinate is automatically subtracted from A... Returns a vector of GCoord's in order of decreasing magnitude of the corresponding eigenvalue. The eigenvalues are returned as a GCoord after the eigenvectors.</p>
<p>Example </p><div class="fragment"><div class="line"><a class="code hl_class" href="classloos_1_1_math_1_1_matrix.html">vector&lt;GCoord&gt;</a> <a class="code hl_class" href="classloos_1_1_math_1_1_matrix.html">V</a> = <a class="code hl_class" href="classloos_1_1_math_1_1_matrix.html">group_of_atoms</a>.principalAxes();</div>
<div class="line"><a class="code hl_class" href="classloos_1_1_coord.html">GCoord</a> eigenvalues = <a class="code hl_class" href="classloos_1_1_math_1_1_matrix.html">V</a>[3];</div>
<div class="line"><a class="code hl_class" href="classloos_1_1_coord.html">GCoord</a> <a class="code hl_class" href="classloos_1_1_math_1_1_matrix.html">first_eigenvector</a> = <a class="code hl_class" href="classloos_1_1_math_1_1_matrix.html">V</a>[0];   <span class="comment">// Most significant</span></div>
<div class="line"><a class="code hl_class" href="classloos_1_1_coord.html">GCoord</a> <a class="code hl_class" href="classloos_1_1_math_1_1_matrix.html">second_eigenvector</a> = <a class="code hl_class" href="classloos_1_1_math_1_1_matrix.html">V</a>[1];</div>
<div class="line"><a class="code hl_class" href="classloos_1_1_coord.html">GCoord</a> <a class="code hl_class" href="classloos_1_1_math_1_1_matrix.html">third_eigenvector</a> = <a class="code hl_class" href="classloos_1_1_math_1_1_matrix.html">V</a>[2];   <span class="comment">// Least significant</span></div>
</div><!-- fragment --><p>Notes</p><ul>
<li>Any errors encountered in the BLAS/LAPACK routines cause a runtime exception to be thrown...</li>
<li><a class="el" href="classloos_1_1_coord.html" title="Basic 3-D coordinates class.">Coord</a> type of contained atoms will always be upcast to double.</li>
<li>Potential issue with f77int under linux when not on a 64-bit architecture. </li>
</ul>

</div>
</div>
<a id="a74e3bf02b3646d2ae45a15cbbe088678" name="a74e3bf02b3646d2ae45a15cbbe088678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74e3bf02b3646d2ae45a15cbbe088678">&#9670;&#160;</a></span>principalAxesOrder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double loos::AtomicGroup::principalAxesOrder </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes order parameter based on principalAxes. </p>
<p>Computes the molecular order parameter by taking 2nd and 3rd principal axes and transforming using a 2nd order Legendre polynomial. This produces a whole-chain quantity with values comparable to deuterium order parameters.</p>
<p>If the <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually)">AtomicGroup</a> is not planar, this returns the average of the order parameter using the 2nd and 3rd axes. If the molecule is planar, indicated by a near-zero 3rd moment, it simply returns the 2nd moment's order parameter.</p>
<p>This implementation assumes you've already done any needed transformations to the coordinates (eg reimaging by molecule) </p>

</div>
</div>
<a id="ab682d7a74a46a65d920f0e362bc72c5a" name="ab682d7a74a46a65d920f0e362bc72c5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab682d7a74a46a65d920f0e362bc72c5a">&#9670;&#160;</a></span>pruneBonds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void loos::AtomicGroup::pruneBonds </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to prune connectivity (only retain bonds to atoms within this <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually)">AtomicGroup</a>) </p>
<p>The connectivity list is searched for each atom and if a bond is not found in the current group, then it is removed from the bond-list for that atom. Note that this means that any <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually)">AtomicGroup</a> sharing the atom in question will also now have the modified bond list. It's therefore recommended that this function be called on a copy (<a class="el" href="#a0dcd01a7efbe31915470ff25dd337d3f" title="Creates a deep copy of this group.">AtomicGroup::copy()</a>). Also note that FindById() does not implicitly sort the atoms for more efficient searching. You may want to call <a class="el" href="#ae4df4c4e55665b8c6f8d09fc467fc35c" title="Sort based on atomid.">AtomicGroup::sort()</a> prior to <a class="el" href="#ab682d7a74a46a65d920f0e362bc72c5a" title="Attempt to prune connectivity (only retain bonds to atoms within this AtomicGroup)">AtomicGroup::pruneBonds()</a> if the exact atom order does not matter. </p>

</div>
</div>
<a id="a4189af9a4ace2bfc2921bb1d57c044d9" name="a4189af9a4ace2bfc2921bb1d57c044d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4189af9a4ace2bfc2921bb1d57c044d9">&#9670;&#160;</a></span>radius()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">greal loos::AtomicGroup::radius </td>
          <td>(</td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>use_atom_as_reference</em><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classloos_1_1_math_1_1_matrix.html">false</a></span></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum radius from centroid of all atoms (not gyration) </p>
<p>If optional argument is true, uses coordinates of atom 0 instead of centroid. Argument is false by default. </p>

</div>
</div>
<a id="a7d8d3c09032f4d4779681353f3b60446" name="a7d8d3c09032f4d4779681353f3b60446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d8d3c09032f4d4779681353f3b60446">&#9670;&#160;</a></span>reimage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void loos::AtomicGroup::reimage </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Translate the entire group so that the centroid is in the primary cell </p>

</div>
</div>
<a id="a6b461aac137353d384db9098e8e2433b" name="a6b461aac137353d384db9098e8e2433b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b461aac137353d384db9098e8e2433b">&#9670;&#160;</a></span>resetAtomIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void loos::AtomicGroup::resetAtomIndices </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the atom indices (used for interfacing with trajectories) </p>
<p>The <a class="el" href="classloos_1_1_atom.html" title="Basic Atom class for handling atom properties.">Atom</a> index is the original ordering of atoms from whatever file format the model came from. This is used as an index into each frame of the trajectory for corresponding atom properties (such as coordinates). If an <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually)">AtomicGroup</a> is a subset, then it may be necessary to reset the indices when working with a subsetted trajectory as well. This function will reset the atom indices to be sequential, beginning with 0. </p>

</div>
</div>
<a id="a727648708aee3f4a3af63aa76cc9b73f" name="a727648708aee3f4a3af63aa76cc9b73f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a727648708aee3f4a3af63aa76cc9b73f">&#9670;&#160;</a></span>rmsd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">greal loos::AtomicGroup::rmsd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the RMSD between two groups. </p>
<p>Assumes a 1:1 correspondence between ith atoms. Does NOT transform the coordinates in any way. </p>

</div>
</div>
<a id="ab8849c3ea931587dfa316b5431f18300" name="ab8849c3ea931587dfa316b5431f18300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8849c3ea931587dfa316b5431f18300">&#9670;&#160;</a></span>scattering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; loos::AtomicGroup::scattering </td>
          <td>(</td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>qmin</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>max</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint</td>          <td class="paramname"><span class="paramname"><em>numValues</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classloos_1_1_form_factor_set.html">loos::FormFactorSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>formFactors</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes X-ray scattering as a function of q, using I(q) = \sum_(atom pair) F_i(q) F_j(q) sin (q d_ij)/ (q d_ij)</p>
<p>This approximates scattering off of individual atoms. If you use this with explicit solvent, you will get truncation artifacts from the periodic box (although the code computes all distances using periodicity).</p>
<p>Form factors are from Szaloki, X-ray Spectrometry (1996), V25, 21-28 </p>

</div>
</div>
<a id="a6f01a0fa6b0ccf7ae7400b2530f85051" name="a6f01a0fa6b0ccf7ae7400b2530f85051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f01a0fa6b0ccf7ae7400b2530f85051">&#9670;&#160;</a></span>setCoords()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void loos::AtomicGroup::setCoords </td>
          <td>(</td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>seq</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>m</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is meant for Numpy/swig use in setting the model's coordinates. The passed array is row-major. </p>

</div>
</div>
<a id="ada45a9d3f6a1e27b4d1b5955be65dfc5" name="ada45a9d3f6a1e27b4d1b5955be65dfc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada45a9d3f6a1e27b4d1b5955be65dfc5">&#9670;&#160;</a></span>sorted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool loos::AtomicGroup::sorted </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the array of atoms already sorted??? </p>
<p>While we make some effort to ensure that alterations to the <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually)">AtomicGroup</a> will invalidate the sorted status, it's a good idea to explicitly sort if you want to make sure that the group is in fact sorted. </p>

</div>
</div>
<a id="a8df78cdd3e971e60d49e3b840680148a" name="a8df78cdd3e971e60d49e3b840680148a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8df78cdd3e971e60d49e3b840680148a">&#9670;&#160;</a></span>sphericalVariance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">greal loos::AtomicGroup::sphericalVariance </td>
          <td>(</td>
          <td class="paramtype">const pAtom</td>          <td class="paramname"><span class="paramname"><em>target</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Spherical variance of group with respect to target atom. </p>
<p>spherical variance as a measure of how much atom "target" is inside this atomic group Mezei, J Mol Graph Modeling, 2003, 21, 463-472 </p>

</div>
</div>
<a id="aafee0233afda44a00ed63d77e7f38ada" name="aafee0233afda44a00ed63d77e7f38ada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafee0233afda44a00ed63d77e7f38ada">&#9670;&#160;</a></span>splitByMolecule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt; loos::AtomicGroup::splitByMolecule </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>selection</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Takes selection string as argument to be applied to each group after splitting. Returns a vector of AtomicGroups split based on bond connectivity; </p>

</div>
</div>
<a id="ade20766165e2c4f35e639f60c44c11c4" name="ade20766165e2c4f35e639f60c44c11c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade20766165e2c4f35e639f60c44c11c4">&#9670;&#160;</a></span>splitByResidue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt; loos::AtomicGroup::splitByResidue </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of AtomicGroups, each comprising a single residue. </p>
<p>Splits an <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually)">AtomicGroup</a> into individual residues. The residue boundary is marked by either a change in the resid or in the segid. </p>

</div>
</div>
<a id="a92e465a871aaeb14915b8205ffccca62" name="a92e465a871aaeb14915b8205ffccca62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92e465a871aaeb14915b8205ffccca62">&#9670;&#160;</a></span>splitByUniqueSegid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &gt; loos::AtomicGroup::splitByUniqueSegid </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of AtomicGroups split from the current group based on segid. </p>
<p>The groups that are returned will be in the same order that the segids appear in the source <a class="el" href="classloos_1_1_atomic_group.html" title="Class for handling groups of Atoms (pAtoms, actually)">AtomicGroup</a> </p>

</div>
</div>
<a id="acea78b92c137a2639d8c83d89448d6cb" name="acea78b92c137a2639d8c83d89448d6cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acea78b92c137a2639d8c83d89448d6cb">&#9670;&#160;</a></span>stacking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">greal loos::AtomicGroup::stacking </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_coord.html">GCoord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>box</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>threshold</em><span class="paramdefsep"> = </span><span class="paramdefval">5.0</span></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Estimate stacking, as between two nucleobases. </p>
<p>Algorithm: n1=normal to self; n2=normal to other, dx = difference between centroids stacking = (n1*n2)^2 *[(n1 + n2)/2 * dx]/|dx| * 1/1 + (dx/threshold)^6 </p>

</div>
</div>
<a id="aaabbe2dcc5ce2aa4f9a46873d0d5a7e8" name="aaabbe2dcc5ce2aa4f9a46873d0d5a7e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaabbe2dcc5ce2aa4f9a46873d0d5a7e8">&#9670;&#160;</a></span>subset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> loos::AtomicGroup::subset </td>
          <td>(</td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>offset</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>len</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="#aaabbe2dcc5ce2aa4f9a46873d0d5a7e8" title="subset() and excise() args are patterned after perl&#39;s substr...">subset()</a> and <a class="el" href="#a8f001aeb52990a0b0c992bde74053376" title="excise returns the excised atoms as a group...">excise()</a> args are patterned after perl's substr... </p>
<p>If offset is negative, then it's relative to the end of the group. If length is 0, then everything from offset to the appropriate end is used... </p>

</div>
</div>
<a id="afc303bb0118c356d6878f75855742733" name="afc303bb0118c356d6878f75855742733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc303bb0118c356d6878f75855742733">&#9670;&#160;</a></span>superposition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classloos_1_1_matrix44.html">GMatrix</a> loos::AtomicGroup::superposition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classloos_1_1_atomic_group.html">AtomicGroup</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>grp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the transformation matrix for superposition of groups. </p>
<p>Uses the Kabsch alignment method (via SVD) to calculate the transformation matrix that superimposes the current group onto the passed group. Returns the matrix.</p>
<p>If too few atoms are given for aligning, the correlation matrix may become singular and return fewer than three eigenpairs. If this is detected, <a class="el" href="#afc303bb0118c356d6878f75855742733" title="Calculates the transformation matrix for superposition of groups.">superposition()</a> will throw a <a class="el" href="classloos_1_1_numerical_error.html" title="Exception caused by a blas/atlas error.">NumericalError</a>. The threshold for a zero-eigenvalue (really, a zero singular value) is set in AtomicGroup::superposition_zero_singular_value </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="_atomic_group_8hpp_source.html">AtomicGroup.hpp</a></li>
<li>src/<b>AG_linalg.cpp</b></li>
<li>src/<b>AG_numerical.cpp</b></li>
<li>src/<b>AtomicGroup.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
