<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LOOS: Selection Language</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LOOS
   &#160;<span id="projectnumber">v3.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('selections.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Selection Language </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="Language"></a>
Description</h1>
<p>The selection string parser is a relatively simpled parser patterned after C/PERL expressions and includes support for PERL-style regular expressions via Boost. There are two kinds of literals supported: strings and numbers. Numbers are any valid integer. Strings are delimited by either single quotes or double quotes, so both of the following are valid strings: </p><pre class="fragment">"a string"
'another string'
</pre><p>An important caveat to integer numbers is that LOOS assumes that none will be negative. In other words, no atomid nor resid nor number extracted from a segid (see <a class="el" href="selections.html#magops_explained">Magical Operations</a> magical ops below) will evaluate to a negative number. The relational operators &lt; and &lt;= will behave differently if either operand is a negative number. In this case, they will evaluate to false, for reasons that will become obvious when you read about the magical operators below...</p>
<p>The parser also recognizes a small set of keywords that evaluate to Atom properties. These keywords fall into two types as well: those that evaluate to a number (id, resid) and those that evaluate to a string (name, resname, chainid, and segname or segid). Keep in mind that keywords are not substitutions, but are more like a pre-defined function that returns that atom property. So you cannot put a keyword in a string and expect it to be substituted with the appropriate value, for example.</p>
<h2><a class="anchor" id="relops"></a>
Relational Operators</h2>
<table align="center" border="1" style="width:80%">
<tr align="left">
<th>Operator</th><th>Operation </th><th>Strings</th><th>Numbers</th><th>Example </th></tr>
<tr align="left">
<td>&gt;</td><td>Greater than</td><td>yes</td><td>yes</td><td>resid &gt; 10 </td></tr>
<tr align="left">
<td>&gt;=</td><td>Greater than or equals</td><td>yes</td><td>yes</td><td>resid &gt;= 10 </td></tr>
<tr align="left">
<td>&lt;=</td><td>Less than or equals</td><td>yes</td><td>yes</td><td>resid &lt;= 50 </td></tr>
<tr align="left">
<td>&lt;</td><td>Less than</td><td>yes</td><td>yes</td><td>resid &lt; 50 </td></tr>
<tr align="left">
<td>==</td><td>Exactly equals</td><td>yes</td><td>yes</td><td>name == "CA" </td></tr>
<tr align="left">
<td>!=</td><td>Doesn't equals exactly</td><td>yes</td><td>yes</td><td>segname != "SOLV" </td></tr>
<tr align="left">
<td>=~</td><td>Regular expression match</td><td>yes</td><td>no</td><td>name =~ "^(C[A]?|N|O)$" </td></tr>
</table>
<h2><a class="anchor" id="logops"></a>
Logical Operators</h2>
<table align="center" border="1" style="width:80%">
<tr align="left">
<th>Operator</th><th>Operation</th><th>Example </th></tr>
<tr align="left">
<td>&amp;&amp;</td><td>Logical And</td><td>name == "CA" &amp;&amp; segid == "PROT" </td></tr>
<tr align="left">
<td>||</td><td>Logical Or</td><td>segid == "SOLV" || segid == "BULK" </td></tr>
<tr align="left">
<td>!</td><td>Not (Negate)</td><td>!(segid == "SOLV") </td></tr>
</table>
<h2><a class="anchor" id="magops"></a>
Magical Operators</h2>
<table align="center" border="1" style="width:80%">
<tr align="left">
<th>Operator</th><th>Operation</th><th>Example </th></tr>
<tr align="left">
<td>-&gt;</td><td>Extracts a number from a string</td><td>segid -&gt; "L(\d+)" </td></tr>
</table>
<h2><a class="anchor" id="keywords"></a>
Keywords</h2>
<table align="center" border="1" style="width:80%">
<tr align="left" valign="top">
<th>Keyword</th><th>Atom Property</th><th>Evaluates to...</th><th>Operators </th></tr>
<tr align="left" valign="top">
<td>name</td><td>Atom name</td><td>string</td><td>&gt;, &gt;=, &lt;=, &lt;, ==, !=, =~ </td></tr>
<tr align="left" valign="top">
<td>id</td><td>Atom ID</td><td>number</td><td>&gt;, &gt;=, &lt;=, &lt;, ==, != </td></tr>
<tr align="left" valign="top">
<td>index</td><td>Atom index in model file (0=based)</td><td>number</td><td>&gt;, &gt;=, &lt;=, &lt;, ==, != </td></tr>
<tr align="left" valign="top">
<td>resname</td><td>Residue name</td><td>string</td><td>&gt;, &gt;=, &lt;=, &lt;, ==, !=, =~ </td></tr>
<tr align="left" valign="top">
<td>resid</td><td>Residue ID</td><td>number</td><td>&gt;, &gt;=, &lt;=, &lt;, ==, != </td></tr>
<tr align="left" valign="top">
<td>segid</td><td>Atom segid</td><td>string</td><td>&gt;, &gt;=, &lt;=, &lt;, ==, !=, =~ </td></tr>
<tr align="left" valign="top">
<td>segname</td><td>Synonym for segid</td><td>string</td><td>&gt;, &gt;=, &lt;=, &lt;, ==, !=, =~ </td></tr>
<tr align="left" valign="top">
<td>chainid</td><td>Chain ID</td><td>string</td><td>&gt;, &gt;=, &lt;=, &lt;, ==, !=, =~ </td></tr>
<tr align="left" valign="top">
<td>all</td><td>Evaluates to true</td><td>number</td><td></td></tr>
<tr align="left" valign="top">
<td>hydrogen</td><td>Evaluates to true if atom is a hydrogen</td><td>number</td><td></td></tr>
<tr align="left" valign="top">
<td>backbone</td><td>Evaluates to true if atom is a backbone atom (nucleic acids and proteins, and includes hydrogens)</td><td>number</td><td></td></tr>
</table>
<p>Notes:<br  />
 The <code>hydrogen</code> selector looks for low-mass atoms with names starting with H. In order to work correctly when hydrogen mass repartitioning is used, the threshold mass has been set to 4.1 amu. This means the selector will produce false positive matches if the system contains helium.</p>
<p>The <code>all</code> keyword is used to force a selection string to match all atoms in instances where a selection is required. For example, a program to align frames of a trajectory DCD to a reference structure might require a selection to pick which atoms to use when computing the rotations and then another selection to pick which atoms are actually rotated. If you wanted to apply the rotation to all atoms, you just use the <code>all</code> keyword, i.e. </p><pre class="fragment">aligner --selection='name='CA' &amp;&amp; segid =~ "BAR[12]"' --transform='all' foo.pdb foo.dcd newfoo
</pre><h2><a class="anchor" id="regexps"></a>
Regular Expression Matching</h2>
<p>The regular expression matching operator "=~" deserves special attention. It's use is more restrictive than the other operators in that it can only take a keyword that evaluates to a string on the left-hand side and a string on the right-hand side. So, the following expressions are valid: </p><pre class="fragment">name =~ "CA"
name =~ "^(C|O|N)$"
segid =~ "PROT|HEME"
</pre><p> While the following are not valid: </p><pre class="fragment">resid =~ "10[0-9][0-9]"
segid =~ 0010
name =~ resname
</pre><p>The regular expression syntax supported is the PERL syntax as implemented by the Boost libraries. While you can write regular expressions that look a lot like globbing (a la VMD selections), keep in mind that it isn't globbing. It's a regular expression, which is more powerful anyway... You do need to be careful though that your shell does not munge any of the regex operators. It's a good idea to use single quotes when you're writing regex's in a shell, or to use configuration files to do the arguments instead (see the <a href="https://github.com/GrossfieldLab/loos/wiki/Using-config-files-instead-of-the-command-line">wiki</a> for a discussion of how to do that).</p>
<p>The string equality operators ("==" and "!=") both consider the <em>entire</em> string. </p><pre class="fragment">"CA" == "C"  --&gt; false
 "C" == "C"  --&gt; true
</pre><p> You can use the "=~" operator to perform a substring match. </p><pre class="fragment">"CA" == "C"  --&gt; false
 "C" == "C"  --&gt; true
"CA" =~ "C"  --&gt; true
</pre><p> This brings up an important point about using regular expressions: be careful of unexpected substring matches. For example, let's say you are wanting to pick out all backbone atoms and you write this selection string: </p><pre class="fragment">name =~ "C|CA|O|N"
</pre><p> Now look what happens when the following atom names are matched: </p><pre class="fragment"> "CG" --&gt; true
"CD1" --&gt; true
 "NE" --&gt; true
"OH2" --&gt; true
</pre><p> The problem is that the regular expression is not constrained, so even though you explicitly put "CA" and "CB" in there, you also have a "C" which says <em>any</em> atom name with a "C" in it is a match. If you want to match a string <em>exactly</em> with a regular expression, you must anchor it: </p><pre class="fragment">name =~ "^(C|CA|CB|O|N)$"
</pre><h2><a class="anchor" id="magops_explained"></a>
Magical Operations</h2>
<p>There is currently only one "magical operator" defined: "-&gt;". This operator takes a string keyword on the left-hand side (i.e. name, resname, or segid/segname) and a string on the right-hand side representing a regular expression pattern. It will then try to extract a numeric value (integer) from the subexpression matches. For example, suppose you have a range of segments that all follow a pattern such as "PG1", "PG2", "PG3", ..., "PG120". The regular expression "PG(\d+)" matches these and the pattern within the parenthesis is a subexpression. So, </p><pre class="fragment">(segid-&gt;"L(\d+)") &gt;= 10 &amp;&amp; (segid-&gt;"L(\d+)") &lt;= 50
</pre><p> will match segid's "L10" through "L50". Since each matched subexpression will be examined for a valid integer conversion, the following will work as expected: </p><pre class="fragment">segid-&gt;"(L|PG)(\d+)"
</pre><p>There is a small hitch with the magical operator. If there is no match, it evaluates to -1. But this is a valid int, so you cannot do the following: </p><pre class="fragment">segid-&gt;"L(\d+)" &lt;= 100
</pre><p> since it will match all segids. You can't, unless the &lt;= operator is also a little bit special. Fortunately, it is. If either operand is a negative number, both the &lt; and &lt;= operands assume that this is a flag for a null-match, and will result in a false value being returned. It's a bit of a kludge, but it works...</p>
<hr  />
 <h1><a class="anchor" id="kahuna"></a>
Putting It All Together...</h1>
<p>When you perform a selection on an AtomicGroup using the selection language, the expression is evaluated once for each atom in the group. If it evaluates to "true" (integer 1), then the atom is added to the new selection. Only one atom is considered at a time.</p>
<p>Here are some example selections: </p><pre class="fragment">Extract C-alphas:
  name == "CA"

Solvent:
  segid == "SOLV" || segid == "BULK"

Solvent heavy atoms (oxygens only)
  name =~ "O" &amp;&amp; (segid == "SOLV" || segid == "BULK")

C-alphas from a range of residues:
  name == "CA" &amp;&amp; resid &gt;= 10 &amp;&amp; resid &lt;= 50
</pre><h2><a class="anchor" id="Usage"></a>
Usage</h2>
<p>Most tools based on LOOS will accept selection strings from the command-line. They must be enclosed in quotes though so they are all one argument to the tool. If you're using regular expressions, it's a good idea to use single quotes to prevent your shell from misinterpreting the regular expression operators and as mentioned before, back-slash escapes may need doubling.</p>
<p>You can store your selection in a file if you want. To use it then, use the back-quote feature of your shell to "cat" your selection file. Since your selection must be one argument, you must enclose the back-quote within double-quotes, i.e. </p><pre class="fragment">  a_tool_name "`cat myselection.txt`" arg arg arg
</pre><p>If you store your selection in a file, then you can also use comments. A comment is anything after a "#" on a line. Here's an example of a selection in a file: </p><pre class="fragment">### Select water oxygens only...
# Pick out any atom that contains an oxygen
name =~ "O" &amp;&amp;
(segid == "SOLV" || # any segment named SOLV
segid == "BULK")    # or named BULK
</pre> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">Lightweight Object-Oriented Structure library (LOOS)</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
